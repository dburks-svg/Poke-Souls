<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scars of Ash</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script src="gamedata.js"></script>
  <script type="text/babel">
    const { useState, useReducer, useEffect, useCallback, useRef } = React;

    // ============= SPRITE REACT COMPONENTS =============
    // AnimatedSprite component - cycles through animation frames
    // Frame rate guide: idle=250ms (4fps), walk=166ms (6fps), battle=125ms (8fps)
    const AnimatedSprite = ({
      frames,           // Array of preloaded Image objects
      frameRate = 250,  // ms per frame - default to idle speed (4fps)
      size = 48,
      flip = false,
      filter = 'none',
      playing = true
    }) => {
      const [frameIndex, setFrameIndex] = React.useState(0);

      React.useEffect(() => {
        if (!playing || !frames || frames.length <= 1) return;
        const interval = setInterval(() => {
          setFrameIndex(i => (i + 1) % frames.length);
        }, frameRate);
        return () => clearInterval(interval);
      }, [frames, frameRate, playing]);

      if (!frames || frames.length === 0) {
        return null;
      }

      const currentFrame = frames[frameIndex % frames.length];

      return (
        <img
          src={currentFrame.src}
          alt="sprite"
          width={size}
          height={size}
          style={{
            imageRendering: 'pixelated',
            transform: flip ? 'scaleX(-1)' : 'none',
            filter: filter
          }}
        />
      );
    };

    // Player sprite facing different directions (16x16 scaled up) - SVG fallback version
    // Each appearance has a distinct silhouette
    const FallbackPlayerSprite = ({ direction = 'down', appearance = 'other' }) => {
      const px = 3; // pixel size (3 = 48px total)
      const palette = PLAYER_PALETTES[appearance] || PLAYER_PALETTES.other;
      const { skin, hair, cloak, cloakLight, pants, outline } = palette;

      // MALE: Short hair, broader shoulders, blue/teal cloak
      const maleSprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short spiky hair */}
            <rect x={5*px} y={1*px} width={6*px} height={2*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={1*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={1*px} fill={hair}/>
            <rect x={6*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            <rect x={9*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={3*px} width={6*px} height={4*px} fill={skin}/>
            {/* Eyes */}
            <rect x={6*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            <rect x={9*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            {/* Broad shoulders/cloak */}
            <rect x={3*px} y={7*px} width={10*px} height={5*px} fill={cloak}/>
            <rect x={2*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={13*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={7*px} y={8*px} width={2*px} height={2*px} fill={cloakLight}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short hair back */}
            <rect x={5*px} y={1*px} width={6*px} height={3*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            {/* Neck */}
            <rect x={6*px} y={4*px} width={4*px} height={3*px} fill={skin}/>
            {/* Broad shoulders/cloak */}
            <rect x={3*px} y={7*px} width={10*px} height={5*px} fill={cloak}/>
            <rect x={2*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={13*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short hair */}
            <rect x={6*px} y={1*px} width={4*px} height={2*px} fill={hair}/>
            <rect x={5*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={7*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={3*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={5*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            {/* Broad cloak */}
            <rect x={4*px} y={7*px} width={7*px} height={5*px} fill={cloak}/>
            <rect x={3*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={8*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short hair */}
            <rect x={6*px} y={1*px} width={4*px} height={2*px} fill={hair}/>
            <rect x={10*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={8*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            {/* Face */}
            <rect x={7*px} y={3*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={10*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            {/* Broad cloak */}
            <rect x={5*px} y={7*px} width={7*px} height={5*px} fill={cloak}/>
            <rect x={12*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Pants */}
            <rect x={6*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        )
      };

      // FEMALE: Long hair with ponytail, red/maroon cloak, slender frame
      const femaleSprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair with side strands */}
            <rect x={5*px} y={1*px} width={6*px} height={3*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={4*px} width={6*px} height={4*px} fill={skin}/>
            {/* Eyes */}
            <rect x={6*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            {/* Slender cloak */}
            <rect x={4*px} y={8*px} width={8*px} height={4*px} fill={cloak}/>
            <rect x={7*px} y={9*px} width={2*px} height={2*px} fill={cloakLight}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair with ponytail */}
            <rect x={5*px} y={1*px} width={6*px} height={4*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={4*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={4*px} fill={hair}/>
            {/* Ponytail down back */}
            <rect x={7*px} y={5*px} width={2*px} height={5*px} fill={hair}/>
            <rect x={7*px} y={10*px} width={2*px} height={2*px} fill={hair}/>
            {/* Slender cloak */}
            <rect x={4*px} y={8*px} width={8*px} height={4*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair */}
            <rect x={6*px} y={1*px} width={4*px} height={3*px} fill={hair}/>
            <rect x={5*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            {/* Ponytail behind */}
            <rect x={10*px} y={3*px} width={2*px} height={2*px} fill={hair}/>
            <rect x={11*px} y={5*px} width={2*px} height={4*px} fill={hair}/>
            {/* Face */}
            <rect x={6*px} y={4*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={6*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            {/* Slender cloak */}
            <rect x={5*px} y={8*px} width={6*px} height={4*px} fill={cloak}/>
            {/* Pants */}
            <rect x={6*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair */}
            <rect x={6*px} y={1*px} width={4*px} height={3*px} fill={hair}/>
            <rect x={10*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            {/* Ponytail behind */}
            <rect x={4*px} y={3*px} width={2*px} height={2*px} fill={hair}/>
            <rect x={3*px} y={5*px} width={2*px} height={4*px} fill={hair}/>
            {/* Face */}
            <rect x={6*px} y={4*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={9*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            {/* Slender cloak */}
            <rect x={5*px} y={8*px} width={6*px} height={4*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={8*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        )
      };

      // OTHER: Hooded figure, purple/gray cloak, face obscured
      const otherSprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood */}
            <rect x={4*px} y={0*px} width={8*px} height={3*px} fill={cloak}/>
            <rect x={3*px} y={1*px} width={1*px} height={4*px} fill={cloak}/>
            <rect x={12*px} y={1*px} width={1*px} height={4*px} fill={cloak}/>
            <rect x={4*px} y={3*px} width={8*px} height={2*px} fill={cloak}/>
            {/* Shadowed face */}
            <rect x={5*px} y={5*px} width={6*px} height={3*px} fill={skin}/>
            {/* Glowing eyes in shadow */}
            <rect x={6*px} y={6*px} width={1*px} height={1*px} fill={cloakLight}/>
            <rect x={9*px} y={6*px} width={1*px} height={1*px} fill={cloakLight}/>
            {/* Cloak body */}
            <rect x={3*px} y={8*px} width={10*px} height={5*px} fill={cloak}/>
            <rect x={6*px} y={9*px} width={4*px} height={2*px} fill={cloakLight}/>
            {/* Legs peek out */}
            <rect x={5*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={9*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood back */}
            <rect x={4*px} y={0*px} width={8*px} height={5*px} fill={cloak}/>
            <rect x={3*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            <rect x={12*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            {/* Hood interior visible */}
            <rect x={5*px} y={2*px} width={6*px} height={3*px} fill={hair}/>
            {/* Cloak body */}
            <rect x={3*px} y={6*px} width={10*px} height={7*px} fill={cloak}/>
            <rect x={6*px} y={8*px} width={4*px} height={3*px} fill={cloakLight}/>
            {/* Legs peek out */}
            <rect x={5*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={9*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood side */}
            <rect x={5*px} y={0*px} width={6*px} height={4*px} fill={cloak}/>
            <rect x={4*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            <rect x={11*px} y={2*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Shadowed face peek */}
            <rect x={5*px} y={4*px} width={3*px} height={3*px} fill={skin}/>
            <rect x={5*px} y={5*px} width={1*px} height={1*px} fill={cloakLight}/>
            {/* Cloak body */}
            <rect x={4*px} y={7*px} width={7*px} height={6*px} fill={cloak}/>
            <rect x={6*px} y={9*px} width={3*px} height={2*px} fill={cloakLight}/>
            {/* Legs */}
            <rect x={5*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={8*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood side */}
            <rect x={5*px} y={0*px} width={6*px} height={4*px} fill={cloak}/>
            <rect x={4*px} y={2*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={11*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            {/* Shadowed face peek */}
            <rect x={8*px} y={4*px} width={3*px} height={3*px} fill={skin}/>
            <rect x={10*px} y={5*px} width={1*px} height={1*px} fill={cloakLight}/>
            {/* Cloak body */}
            <rect x={5*px} y={7*px} width={7*px} height={6*px} fill={cloak}/>
            <rect x={7*px} y={9*px} width={3*px} height={2*px} fill={cloakLight}/>
            {/* Legs */}
            <rect x={6*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={9*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        )
      };

      // Select sprite set based on appearance
      const spriteSet = appearance === 'male' ? maleSprites :
                        appearance === 'female' ? femaleSprites :
                        otherSprites;

      return spriteSet[direction] || spriteSet.down;
    };

    // Main player sprite component
    // GIF sprites for male (browser-animated), SVG fallback for others.
    // 400ms delay before transitioning from walk GIF to idle GIF.
    const PlayerSprite = ({ direction = 'down', appearance = 'other', isMoving = false }) => {
      const [showWalk, setShowWalk] = React.useState(false);
      const [bobUp, setBobUp] = React.useState(false);
      const walkTimeoutRef = React.useRef(null);

      // Handle walk-to-idle transition with 400ms delay
      React.useEffect(() => {
        if (isMoving) {
          if (walkTimeoutRef.current) {
            clearTimeout(walkTimeoutRef.current);
            walkTimeoutRef.current = null;
          }
          setShowWalk(true);
        } else if (showWalk) {
          walkTimeoutRef.current = setTimeout(() => {
            setShowWalk(false);
            walkTimeoutRef.current = null;
          }, 400);
        }
        return () => {
          if (walkTimeoutRef.current) {
            clearTimeout(walkTimeoutRef.current);
          }
        };
      }, [isMoving]);

      // Bob animation for SVG fallback movement
      React.useEffect(() => {
        if (!isMoving) {
          setBobUp(false);
          return;
        }
        const interval = setInterval(() => {
          setBobUp(prev => !prev);
        }, 200);
        return () => clearInterval(interval);
      }, [isMoving]);

      // Check for preloaded GIF sprite (single Image, not array)
      const animType = showWalk ? 'walk' : 'idle';
      const sprite = preloadedSprites.player[appearance]?.[direction]?.[animType];

      if (sprite && !Array.isArray(sprite)) {
        return (
          <div style={{ width: 48, height: 48, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <img src={sprite.src} width={48} height={48} style={{ imageRendering: 'pixelated' }} />
          </div>
        );
      }

      // Fallback: SVG with bob animation for movement
      return (
        <div style={{ transform: isMoving && bobUp ? 'translateY(-2px)' : 'none' }}>
          <FallbackPlayerSprite direction={direction} appearance={appearance} />
        </div>
      );
    };

    // Creature sprites - SVG fallback version
    const FallbackCreatureSprite = ({ type, size = 48, isEnemy = false }) => {
      const px = size / 16;

      const sprites = {
        fire: ( // Cindrath - flame creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#c53030"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#c53030"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#ed8936"/>
            <rect x={6*px} y={10*px} width={4*px} height={2*px} fill="#f6e05e"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            {/* Flames on head */}
            <rect x={6*px} y={4*px} width={1*px} height={3*px} fill="#ed8936"/>
            <rect x={8*px} y={3*px} width={1*px} height={4*px} fill="#f6ad55"/>
            <rect x={9*px} y={5*px} width={1*px} height={2*px} fill="#ed8936"/>
            <rect x={7*px} y={2*px} width={2*px} height={2*px} fill="#f6e05e"/>
            {/* Feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#742a2a"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#742a2a"/>
          </svg>
        ),
        water: ( // Marshveil - water creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body - rounded blob */}
            <rect x={3*px} y={6*px} width={10*px} height={8*px} fill="#2b6cb0"/>
            <rect x={4*px} y={5*px} width={8*px} height={1*px} fill="#2b6cb0"/>
            <rect x={4*px} y={14*px} width={8*px} height={1*px} fill="#2b6cb0"/>
            {/* Inner shine */}
            <rect x={4*px} y={7*px} width={8*px} height={6*px} fill="#4299e1"/>
            <rect x={5*px} y={8*px} width={4*px} height={3*px} fill="#63b3ed"/>
            {/* Eyes */}
            <rect x={5*px} y={8*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={9*px} y={8*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={5*px} y={8*px} width={1*px} height={1*px} fill="#e8e8e8"/>
            <rect x={9*px} y={8*px} width={1*px} height={1*px} fill="#e8e8e8"/>
            {/* Fins/frills */}
            <rect x={1*px} y={8*px} width={2*px} height={4*px} fill="#4299e1"/>
            <rect x={13*px} y={8*px} width={2*px} height={4*px} fill="#4299e1"/>
            {/* Water drops */}
            <rect x={7*px} y={3*px} width={2*px} height={2*px} fill="#90cdf4"/>
          </svg>
        ),
        grass: ( // Thornwick - plant creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#276749"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#276749"/>
            {/* Inner */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#38a169"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#c53030"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#c53030"/>
            {/* Leaves/thorns on top */}
            <rect x={5*px} y={4*px} width={2*px} height={3*px} fill="#48bb78"/>
            <rect x={7*px} y={2*px} width={2*px} height={5*px} fill="#68d391"/>
            <rect x={9*px} y={4*px} width={2*px} height={3*px} fill="#48bb78"/>
            {/* Thorns */}
            <rect x={3*px} y={10*px} width={1*px} height={2*px} fill="#68d391"/>
            <rect x={12*px} y={10*px} width={1*px} height={2*px} fill="#68d391"/>
            {/* Roots/feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1c4532"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1c4532"/>
          </svg>
        ),
        boss: ( // Obsidian Hound
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={2*px} y={8*px} width={12*px} height={5*px} fill="#1a1a2e"/>
            <rect x={3*px} y={7*px} width={10*px} height={1*px} fill="#1a1a2e"/>
            {/* Head */}
            <rect x={10*px} y={4*px} width={5*px} height={5*px} fill="#2d3748"/>
            <rect x={11*px} y={3*px} width={3*px} height={1*px} fill="#2d3748"/>
            {/* Ears */}
            <rect x={11*px} y={1*px} width={1*px} height={2*px} fill="#2d3748"/>
            <rect x={14*px} y={1*px} width={1*px} height={2*px} fill="#2d3748"/>
            {/* Eyes - glowing */}
            <rect x={11*px} y={5*px} width={2*px} height={2*px} fill="#f56565"/>
            <rect x={12*px} y={5*px} width={1*px} height={1*px} fill="#feb2b2"/>
            {/* Snout */}
            <rect x={14*px} y={6*px} width={2*px} height={2*px} fill="#4a5568"/>
            {/* Legs */}
            <rect x={3*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={6*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={9*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={12*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            {/* Fire markings */}
            <rect x={4*px} y={9*px} width={1*px} height={2*px} fill="#ed8936"/>
            <rect x={7*px} y={8*px} width={1*px} height={3*px} fill="#f6ad55"/>
            {/* Tail */}
            <rect x={0*px} y={7*px} width={2*px} height={2*px} fill="#2d3748"/>
          </svg>
        ),
        dark: ( // Umbravine - dark vine creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#2d2040"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#2d2040"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#4a3060"/>
            {/* Eyes - glowing violet */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={6*px} y={9*px} width={1*px} height={1*px} fill="#e9d8fd"/>
            <rect x={10*px} y={9*px} width={1*px} height={1*px} fill="#e9d8fd"/>
            {/* Vine tendrils */}
            <rect x={3*px} y={5*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={2*px} y={4*px} width={1*px} height={2*px} fill="#553c9a"/>
            <rect x={12*px} y={5*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={13*px} y={4*px} width={1*px} height={2*px} fill="#553c9a"/>
            {/* Top vines */}
            <rect x={6*px} y={3*px} width={1*px} height={4*px} fill="#6b46c1"/>
            <rect x={9*px} y={4*px} width={1*px} height={3*px} fill="#6b46c1"/>
            <rect x={7*px} y={2*px} width={2*px} height={2*px} fill="#805ad5"/>
            {/* Roots/feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1a1030"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1a1030"/>
          </svg>
        ),
        light: ( // Solrath - light creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#d69e2e"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#d69e2e"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#ecc94b"/>
            <rect x={6*px} y={10*px} width={4*px} height={2*px} fill="#faf089"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            {/* Radiating light rays */}
            <rect x={7*px} y={1*px} width={2*px} height={5*px} fill="#faf089"/>
            <rect x={2*px} y={6*px} width={3*px} height={2*px} fill="#f6e05e"/>
            <rect x={11*px} y={6*px} width={3*px} height={2*px} fill="#f6e05e"/>
            <rect x={3*px} y={3*px} width={2*px} height={2*px} fill="#f6e05e"/>
            <rect x={11*px} y={3*px} width={2*px} height={2*px} fill="#f6e05e"/>
            {/* Warm glow halo */}
            <rect x={6*px} y={3*px} width={4*px} height={1*px} fill="#fefcbf"/>
            {/* Feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#b7791f"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#b7791f"/>
          </svg>
        ),
        hollowWarden: ( // Hollow Warden - corrupted dark/light hybrid
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body - fractured */}
            <rect x={2*px} y={7*px} width={12*px} height={7*px} fill="#1a1020"/>
            <rect x={3*px} y={6*px} width={10*px} height={1*px} fill="#1a1020"/>
            {/* Corruption cracks */}
            <rect x={4*px} y={8*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={8*px} y={7*px} width={1*px} height={5*px} fill="#9f7aea"/>
            <rect x={11*px} y={9*px} width={1*px} height={3*px} fill="#553c9a"/>
            {/* Head */}
            <rect x={5*px} y={2*px} width={6*px} height={5*px} fill="#2d2040"/>
            {/* Eyes - one dark, one light */}
            <rect x={6*px} y={4*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={10*px} y={4*px} width={2*px} height={2*px} fill="#faf089"/>
            {/* Crown of fractured light */}
            <rect x={6*px} y={0*px} width={1*px} height={2*px} fill="#f6e05e"/>
            <rect x={8*px} y={0*px} width={1*px} height={3*px} fill="#faf089"/>
            <rect x={10*px} y={1*px} width={1*px} height={2*px} fill="#f6e05e"/>
            {/* Arms/appendages */}
            <rect x={0*px} y={9*px} width={2*px} height={3*px} fill="#2d2040"/>
            <rect x={14*px} y={9*px} width={2*px} height={3*px} fill="#2d2040"/>
            {/* Legs */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1a1020"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1a1020"/>
          </svg>
        )
      };

      return sprites[type] || sprites.fire;
    };

    // Main creature sprite component - uses PNG if available, falls back to SVG
    // Now supports 4-frame idle animations
    const CreatureSprite = ({ type, size = 48, isEnemy = false, scarCount = 0, isHollowed = false, bossPhase = 1, animated = true }) => {
      // Determine which sprite variant to use
      const useHollowed = isHollowed || scarCount >= SCAR_THRESHOLD_HOLLOWED;

      // Check if we have PNG sprite frames loaded for this type
      const isBossType = type === 'boss' || type === 'hollowWarden';
      let frames = null;

      if (isBossType) {
        const phaseKey = bossPhase === 2 ? 'phase2' : 'phase1';
        frames = preloadedSprites.creatures[type]?.[phaseKey]?.idle;
      } else {
        const variant = useHollowed ? 'hollowed' : 'base';
        frames = preloadedSprites.creatures[type]?.[variant]?.idle;
        // Fall back to base if hollowed not available
        if (!frames && useHollowed) {
          frames = preloadedSprites.creatures[type]?.base?.idle;
        }
      }

      // If PNG sprite frames are available, render animated sprite
      // Battle animations use 8fps (125ms) for more dynamic feel
      if (frames && frames.length > 0) {
        return (
          <AnimatedSprite
            frames={frames}
            frameRate={125}
            size={size}
            flip={isEnemy}
            filter={useHollowed && !isBossType ? 'saturate(0.5) brightness(0.8)' : 'none'}
            playing={animated}
          />
        );
      }

      // Fall back to SVG sprite (no animation)
      return <FallbackCreatureSprite type={type} size={size} isEnemy={isEnemy} />;
    };

    // Tile components - area-aware for distinct visual styles
    const GrassTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isHollow = area === 'hollowDeep';
      const isLabyrinth = area === 'labyrinth';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.grassDark,
          position: 'relative',
          overflow: 'hidden',
          animation: isHollow ? 'voidPulse 3s ease-in-out infinite' :
                     isLabyrinth ? 'mazeGlow 4s ease-in-out infinite' : 'none'
        }}>
          {/* Grass blades pattern with area-specific colors */}
          <svg width="56" height="56" style={{
            position: 'absolute',
            top: 0,
            left: 0,
            animation: 'grassSway 2s ease-in-out infinite'
          }}>
            <rect x="6" y="16" width="3" height="12" fill={palette.grassMid}/>
            <rect x="6" y="13" width="3" height="3" fill={palette.grassLight}/>
            <rect x="16" y="20" width="3" height="14" fill={palette.grassMid}/>
            <rect x="16" y="17" width="3" height="3" fill={palette.grassLight}/>
            <rect x="28" y="14" width="3" height="16" fill={palette.grassMid}/>
            <rect x="28" y="11" width="3" height="3" fill={palette.grassLight}/>
            <rect x="40" y="18" width="3" height="12" fill={palette.grassMid}/>
            <rect x="40" y="15" width="3" height="3" fill={palette.grassLight}/>
            <rect x="50" y="16" width="3" height="14" fill={palette.grassMid}/>
            <rect x="50" y="13" width="3" height="3" fill={palette.grassLight}/>
            <rect x="11" y="34" width="3" height="12" fill={palette.grassMid}/>
            <rect x="22" y="38" width="3" height="12" fill={palette.grassMid}/>
            <rect x="34" y="32" width="3" height="14" fill={palette.grassMid}/>
            <rect x="45" y="36" width="3" height="14" fill={palette.grassMid}/>
          </svg>
          {/* Void particles for Hollow Deep */}
          {isHollow && (
            <>
              <div style={{
                position: 'absolute',
                top: '8px',
                left: '12px',
                width: '4px',
                height: '4px',
                backgroundColor: palette.void,
                borderRadius: '50%',
                animation: 'ember 2s infinite',
                opacity: 0.7
              }}/>
              <div style={{
                position: 'absolute',
                bottom: '12px',
                right: '10px',
                width: '3px',
                height: '3px',
                backgroundColor: palette.accent,
                borderRadius: '50%',
                animation: 'ember 2.5s infinite 0.5s',
                opacity: 0.6
              }}/>
            </>
          )}
        </div>
      );
    };

    const PathTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isKeep = area === 'fallenKeep';
      const isLabyrinth = area === 'labyrinth';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.pathMid,
          position: 'relative',
          boxShadow: isLabyrinth ? `inset 0 0 8px ${palette.glow}` : 'none'
        }}>
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Stone/dirt texture with area-specific colors */}
            <rect x="3" y="5" width="12" height="6" fill={palette.pathLight}/>
            <rect x="22" y="3" width="14" height="8" fill={palette.pathDark}/>
            <rect x="44" y="8" width="9" height="6" fill={palette.pathLight}/>
            <rect x="8" y="22" width="16" height="7" fill={palette.pathDark}/>
            <rect x="34" y="20" width="12" height="8" fill={palette.pathLight}/>
            <rect x="5" y="40" width="9" height="6" fill={palette.pathLight}/>
            <rect x="20" y="42" width="14" height="6" fill={palette.pathDark}/>
            <rect x="42" y="38" width="11" height="8" fill={palette.pathDark}/>
            {/* Labyrinth ancient runes */}
            {isLabyrinth && (
              <>
                <rect x="24" y="24" width="8" height="2" fill={palette.ancient} opacity="0.4"/>
                <rect x="26" y="22" width="2" height="6" fill={palette.ancient} opacity="0.3"/>
              </>
            )}
          </svg>
          {/* Ashen wind particles for Ashen Path */}
          {area === 'ashenPath' && Math.random() > 0.7 && (
            <div style={{
              position: 'absolute',
              top: '20px',
              left: '10px',
              width: '6px',
              height: '2px',
              backgroundColor: palette.accent,
              animation: 'ashenWind 3s ease-in-out infinite',
              opacity: 0.4
            }}/>
          )}
        </div>
      );
    };

    const WallTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isKeep = area === 'fallenKeep';
      const isHollow = area === 'hollowDeep';
      const isLabyrinth = area === 'labyrinth';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallDark,
          position: 'relative',
          boxShadow: isHollow ? `inset 0 0 12px ${palette.glow}` :
                     isLabyrinth ? `inset 0 0 6px ${palette.glow}` : 'none'
        }}>
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Brick pattern with area-specific colors */}
            <rect x="0" y="0" width="26" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="28" y="0" width="28" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="0" y="14" width="14" height="13" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="16" y="14" width="26" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="44" y="14" width="12" height="13" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="0" y="28" width="22" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="24" y="28" width="32" height="13" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="0" y="42" width="12" height="14" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="14" y="42" width="26" height="14" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="42" y="42" width="14" height="14" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            {/* Hollow Deep void cracks */}
            {isHollow && (
              <>
                <line x1="10" y1="20" x2="18" y2="35" stroke={palette.void} strokeWidth="2" opacity="0.6"/>
                <line x1="40" y1="8" x2="45" y2="22" stroke={palette.accent} strokeWidth="1" opacity="0.4"/>
              </>
            )}
            {/* Labyrinth ancient symbols */}
            {isLabyrinth && (
              <>
                <circle cx="28" cy="28" r="6" fill="none" stroke={palette.ancient} strokeWidth="1" opacity="0.3"/>
                <rect x="25" y="25" width="6" height="6" fill="none" stroke={palette.mystery} strokeWidth="1" opacity="0.2"/>
              </>
            )}
          </svg>
        </div>
      );
    };

    const BonfireTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.pathDark,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {/* Fire base */}
          <div style={{
            position: 'absolute',
            bottom: '6px',
            width: '32px',
            height: '10px',
            backgroundColor: '#4a3728',
            borderRadius: '2px'
          }}/>
          {/* Animated flames */}
          <svg width="44" height="44" style={{ animation: 'flicker 0.5s infinite', position: 'relative', zIndex: 1 }}>
            {/* Outer flame */}
            <rect x="10" y="22" width="24" height="16" fill="#ed8936"/>
            <rect x="13" y="16" width="18" height="8" fill="#f6ad55"/>
            <rect x="16" y="10" width="12" height="8" fill="#f6e05e"/>
            <rect x="19" y="4" width="6" height="8" fill="#faf089"/>
            {/* Inner bright core */}
            <rect x="16" y="26" width="12" height="8" fill="#faf089"/>
            <rect x="19" y="20" width="6" height="8" fill="#fffff0"/>
          </svg>
          {/* Embers */}
          <div style={{
            position: 'absolute',
            top: '10px',
            left: '16px',
            width: '5px',
            height: '5px',
            backgroundColor: '#f6e05e',
            animation: 'ember 1s infinite',
            animationDelay: '0s'
          }}/>
          <div style={{
            position: 'absolute',
            top: '12px',
            right: '18px',
            width: '4px',
            height: '4px',
            backgroundColor: '#ed8936',
            animation: 'ember 1.2s infinite',
            animationDelay: '0.3s'
          }}/>
          {/* Area-specific glow */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            boxShadow: `inset 0 0 20px rgba(237, 137, 54, 0.3)`,
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    const GateTile = ({ isKeep = false, area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: isKeep ? palette.wallMid : palette.pathMid,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <svg width="50" height="50" style={{ imageRendering: 'pixelated' }}>
            {/* Torii gate / dungeon entrance */}
            {/* Pillars */}
            <rect x="6" y="12" width="6" height="38" fill="#742a2a"/>
            <rect x="38" y="12" width="6" height="38" fill="#742a2a"/>
            {/* Top beam */}
            <rect x="3" y="6" width="44" height="6" fill="#9b2c2c"/>
            <rect x="0" y="3" width="50" height="5" fill="#c53030"/>
            {/* Cross beam */}
            <rect x="6" y="16" width="38" height="4" fill="#742a2a"/>
            {/* Entrance darkness */}
            <rect x="14" y="22" width="22" height="28" fill="#0f0f1a"/>
          </svg>
        </div>
      );
    };

    const BossRoomTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isHollow = area === 'hollowDeep';
      const eyeColor = isHollow ? '#9f7aea' : '#c53030';
      const eyeColor2 = isHollow ? '#faf089' : '#c53030';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: isHollow ? '#0d0a14' : '#1a0a0a',
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          animation: isHollow ? 'voidPulse 2s ease-in-out infinite' : 'none'
        }}>
          <svg width="50" height="50" style={{ imageRendering: 'pixelated' }}>
            {/* Skull */}
            <rect x="13" y="10" width="24" height="20" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            <rect x="10" y="13" width="3" height="14" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            <rect x="37" y="13" width="3" height="14" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            {/* Eye sockets */}
            <rect x="16" y="16" width="6" height="7" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            <rect x="28" y="16" width="6" height="7" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            {/* Glowing eyes */}
            <rect x="18" y="18" width="3" height="3" fill={eyeColor}/>
            <rect x="30" y="18" width="3" height="3" fill={eyeColor2}/>
            {/* Nose */}
            <rect x="22" y="25" width="6" height="4" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            {/* Teeth */}
            <rect x="16" y="30" width="18" height="6" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            <rect x="19" y="30" width="3" height="6" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            <rect x="25" y="30" width="3" height="6" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            <rect x="31" y="30" width="3" height="6" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            {/* Jaw */}
            <rect x="13" y="36" width="24" height="6" fill={isHollow ? '#8080a0' : '#d4d4d4'}/>
          </svg>
        </div>
      );
    };

    // Torch tile for Fallen Keep atmosphere
    const TorchTile = ({ area = 'fallenKeep' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.fallenKeep;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallMid,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Wall base */}
            <rect x="0" y="0" width="56" height="56" fill={palette.wallMid}/>
            {/* Torch bracket */}
            <rect x="22" y="20" width="12" height="4" fill="#4a3728"/>
            <rect x="24" y="24" width="8" height="16" fill="#5a4a3a"/>
            {/* Torch head */}
            <rect x="23" y="10" width="10" height="12" fill="#6b5040"/>
          </svg>
          {/* Animated flame */}
          <svg width="20" height="20" style={{
            position: 'absolute',
            top: '2px',
            animation: 'torchFlicker 0.4s infinite'
          }}>
            <rect x="4" y="10" width="12" height="8" fill="#ed8936"/>
            <rect x="6" y="6" width="8" height="6" fill="#f6ad55"/>
            <rect x="7" y="2" width="6" height="6" fill="#f6e05e"/>
            <rect x="8" y="0" width="4" height="4" fill="#faf089"/>
          </svg>
          {/* Light glow effect */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            background: `radial-gradient(circle at 50% 30%, ${palette.glow} 0%, transparent 60%)`,
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    // Ashen Gate - massive door at end of Labyrinth
    const AshenGateTile = ({ area = 'labyrinth' }) => {
      const palette = AREA_PALETTES.labyrinth;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallDark,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          animation: 'mazeGlow 3s ease-in-out infinite'
        }}>
          <svg width="56" height="56" style={{ imageRendering: 'pixelated' }}>
            {/* Massive door frame */}
            <rect x="4" y="2" width="48" height="52" fill="#2a2520"/>
            <rect x="8" y="6" width="40" height="44" fill="#1a1510"/>
            {/* Door panels */}
            <rect x="10" y="8" width="16" height="40" fill="#3a3530" stroke="#2a2520" strokeWidth="1"/>
            <rect x="30" y="8" width="16" height="40" fill="#3a3530" stroke="#2a2520" strokeWidth="1"/>
            {/* Ancient runes */}
            <rect x="16" y="14" width="4" height="8" fill={palette.ancient} opacity="0.6"/>
            <rect x="36" y="14" width="4" height="8" fill={palette.ancient} opacity="0.6"/>
            {/* Central emblem - flame symbol */}
            <rect x="24" y="20" width="8" height="12" fill={palette.ancient}/>
            <rect x="26" y="16" width="4" height="6" fill={palette.ancient}/>
            <rect x="27" y="12" width="2" height="6" fill="#faf089"/>
            {/* Door handles */}
            <circle cx="24" cy="36" r="3" fill="#8b7355"/>
            <circle cx="32" cy="36" r="3" fill="#8b7355"/>
          </svg>
          {/* Mystical glow */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            background: `radial-gradient(ellipse at 50% 50%, rgba(246, 224, 94, 0.2) 0%, transparent 70%)`,
            animation: 'lorePulse 2s ease-in-out infinite',
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    // Secret door tile - hidden until revealed
    const SecretDoorTile = ({ revealed = false, area = 'labyrinth' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.labyrinth;

      if (!revealed) {
        // Looks like a normal wall with subtle cracks
        return (
          <div style={{
            width: '100%',
            height: '100%',
            backgroundColor: palette.wallDark,
            position: 'relative'
          }}>
            <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
              <rect x="0" y="0" width="56" height="56" fill={palette.wallMid}/>
              {/* Subtle cracks - hint */}
              <line x1="10" y1="15" x2="18" y2="42" stroke={palette.wallLight} strokeWidth="1" opacity="0.5"/>
              <line x1="38" y1="12" x2="45" y2="45" stroke={palette.wallLight} strokeWidth="1" opacity="0.5"/>
              <line x1="10" y1="42" x2="46" y2="44" stroke={palette.wallLight} strokeWidth="1" opacity="0.4"/>
            </svg>
          </div>
        );
      }

      // Revealed secret door
      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallDark,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <svg width="56" height="56" style={{ imageRendering: 'pixelated' }}>
            {/* Door frame */}
            <rect x="8" y="4" width="40" height="48" fill="#1a1510"/>
            <rect x="12" y="8" width="32" height="40" fill="#0f0f1a"/>
            {/* Ancient markings */}
            <rect x="14" y="12" width="2" height="30" fill={palette.ancient} opacity="0.4"/>
            <rect x="40" y="12" width="2" height="30" fill={palette.ancient} opacity="0.4"/>
          </svg>
          {/* Shimmer effect */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            animation: 'secretShimmer 2s ease-in-out infinite',
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    // Lore object indicator tile - shows examinable props
    const LoreObjectTile = ({ objectType = 'generic', area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;

      const renderObject = () => {
        switch (objectType) {
          case 'statue':
            return (
              <svg width="40" height="48" style={{ imageRendering: 'pixelated' }}>
                {/* Statue base */}
                <rect x="8" y="40" width="24" height="8" fill="#5a5a60"/>
                {/* Body */}
                <rect x="12" y="20" width="16" height="22" fill="#7a7a85"/>
                {/* Head */}
                <rect x="14" y="10" width="12" height="12" fill="#8a8a95"/>
                {/* Arms */}
                <rect x="6" y="24" width="6" height="12" fill="#7a7a85"/>
                <rect x="28" y="24" width="6" height="12" fill="#7a7a85"/>
              </svg>
            );
          case 'altar':
            return (
              <svg width="48" height="40" style={{ imageRendering: 'pixelated' }}>
                {/* Altar base */}
                <rect x="4" y="28" width="40" height="12" fill="#5a4a3a"/>
                <rect x="8" y="20" width="32" height="10" fill="#6b5a4a"/>
                {/* Candles */}
                <rect x="12" y="14" width="4" height="8" fill="#e8e8e0"/>
                <rect x="32" y="14" width="4" height="8" fill="#e8e8e0"/>
                {/* Flames */}
                <rect x="13" y="10" width="2" height="4" fill="#f6ad55"/>
                <rect x="33" y="10" width="2" height="4" fill="#f6ad55"/>
              </svg>
            );
          case 'bones':
            return (
              <svg width="44" height="36" style={{ imageRendering: 'pixelated' }}>
                {/* Scattered bones */}
                <rect x="4" y="24" width="16" height="4" fill="#e8e8d8" transform="rotate(-15 12 26)"/>
                <rect x="24" y="20" width="14" height="4" fill="#e0e0d0" transform="rotate(20 31 22)"/>
                <rect x="10" y="12" width="10" height="4" fill="#d8d8c8" transform="rotate(-5 15 14)"/>
                {/* Skull */}
                <circle cx="34" cy="10" r="6" fill="#e8e8d8"/>
                <rect x="31" y="8" width="2" height="2" fill="#1a1a1a"/>
                <rect x="35" y="8" width="2" height="2" fill="#1a1a1a"/>
              </svg>
            );
          case 'torch':
            return (
              <svg width="24" height="48" style={{ imageRendering: 'pixelated' }}>
                {/* Torch handle */}
                <rect x="8" y="20" width="8" height="28" fill="#5a4a3a"/>
                {/* Torch head */}
                <rect x="6" y="14" width="12" height="8" fill="#6b5040"/>
                {/* Flame */}
                <rect x="8" y="6" width="8" height="10" fill="#ed8936"/>
                <rect x="9" y="2" width="6" height="6" fill="#f6ad55"/>
                <rect x="10" y="0" width="4" height="4" fill="#f6e05e"/>
              </svg>
            );
          case 'chest':
            return (
              <svg width="40" height="32" style={{ imageRendering: 'pixelated' }}>
                {/* Chest body */}
                <rect x="4" y="12" width="32" height="20" fill="#8b7355"/>
                <rect x="4" y="8" width="32" height="8" fill="#a08060" rx="2"/>
                {/* Metal bands */}
                <rect x="4" y="16" width="32" height="3" fill="#4a4a50"/>
                <rect x="4" y="24" width="32" height="3" fill="#4a4a50"/>
                {/* Lock */}
                <rect x="16" y="18" width="8" height="6" fill="#d69e2e"/>
                <rect x="18" y="20" width="4" height="2" fill="#1a1a1a"/>
              </svg>
            );
          default:
            return (
              <svg width="32" height="32" style={{ imageRendering: 'pixelated' }}>
                <rect x="8" y="8" width="16" height="16" fill={palette.accent} opacity="0.6"/>
              </svg>
            );
        }
      };

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.pathMid,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {/* Base path texture */}
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            <rect x="3" y="5" width="12" height="6" fill={palette.pathLight}/>
            <rect x="22" y="3" width="14" height="8" fill={palette.pathDark}/>
            <rect x="44" y="8" width="9" height="6" fill={palette.pathLight}/>
          </svg>
          {/* Object */}
          <div style={{ position: 'relative', zIndex: 2 }}>
            {renderObject()}
          </div>
          {/* Lore indicator glow */}
          <div style={{
            position: 'absolute',
            bottom: '4px',
            width: '8px',
            height: '8px',
            backgroundColor: GBC.gold,
            borderRadius: '50%',
            animation: 'lorePulse 1.5s ease-in-out infinite',
            boxShadow: '0 0 6px rgba(246, 224, 94, 0.8)'
          }}/>
        </div>
      );
    };


    // ============= BATTLE HELPERS =============
    function handleCreatureFaint(state, team, enemy, log) {
      const difficulty = getDifficulty(state);
      const activeCreature = team[state.activeCreatureIndex];
      const scar = getRandomScar(difficulty);

      activeCreature.hp = 0;
      activeCreature.scars = [...(activeCreature.scars || []), scar];

      log.push(`${activeCreature.nickname || activeCreature.name} has fallen!`);
      const scarMessages = [
        `${activeCreature.nickname || activeCreature.name} gained a scar. It's a look.`,
        `Another scar for ${activeCreature.nickname || activeCreature.name}. Basically tattoos at this point.`
      ];
      log.push(scarMessages[Math.floor(Math.random() * scarMessages.length)]);
      log.push(`   ${scar.name}: ${scar.description}`);

      if (activeCreature.scars.length >= difficulty.hollowedThreshold) {
        log.push(`${activeCreature.nickname || activeCreature.name} has become Hollowed...`);
      }

      team[state.activeCreatureIndex] = activeCreature;

      const availableIndex = team.findIndex((c, i) => i !== state.activeCreatureIndex && c.hp > 0);

      if (availableIndex === -1) {
        // Calculate souls to drop based on difficulty
        let soulsToDrop = Math.floor(state.souls * difficulty.soulDropPercent);
        if (difficulty.dropBankedSouls) {
          soulsToDrop += state.bankedSouls;
        }

        const droppedSouls = soulsToDrop > 0 ? {
          map: state.currentMap,
          pos: { ...state.playerPos },
          amount: soulsToDrop
        } : state.droppedSouls;

        // Add boss death dialogue if dying to boss
        if (state.isBossFight) {
          BOSS_DIALOGUE.playerDeath.forEach(line => log.push(line));
        }

        return {
          ...state,
          screen: 'gameOver',
          team,
          enemy,
          battleLog: log,
          souls: 0,
          bankedSouls: difficulty.dropBankedSouls ? 0 : state.bankedSouls,
          droppedSouls,
          diedToBoss: state.isBossFight
        };
      }

      return {
        ...state,
        team,
        enemy,
        battleLog: log,
        activeCreatureIndex: availableIndex,
        turnPhase: 'player'
      };
    }

    // ============= GAME REDUCER =============
    function gameReducer(state, action) {
      switch (action.type) {
        case 'CREATE_CHARACTER': {
          if (!action.name || !action.appearance) return state;
          return {
            ...state,
            playerName: action.name.trim(),
            playerAppearance: action.appearance,
            screen: 'difficulty'
          };
        }

        case 'SELECT_DIFFICULTY': {
          return {
            ...state,
            difficulty: action.difficulty,
            screen: 'starter'
          };
        }

        case 'SELECT_STARTER': {
          const starterData = STARTERS[action.starter];
          const newCreature = {
            ...starterData,
            hp: starterData.maxHp,
            stamina: starterData.maxStamina,
            scars: [],
            winded: false,
            isGuarding: false,
            burnTurns: 0,
            poisonTurns: 0,
            chillTurns: 0
          };
          // Show prologue on first playthrough
          const nextScreen = state.hasSeenPrologue ? 'exploration' : 'prologue';
          return {
            ...state,
            screen: nextScreen,
            team: [newCreature]
          };
        }

        case 'CONTINUE_FROM_PROLOGUE': {
          return {
            ...state,
            screen: 'exploration',
            hasSeenPrologue: true
          };
        }

        case 'EXAMINE_TILE': {
          const key = `${state.playerPos.x},${state.playerPos.y}`;
          const lore = TILE_LORE[state.currentMap]?.[key];

          // Labyrinth secret room clue tracking
          const LABYRINTH_CLUES = ['16,1', '1,7', '4,15', '17,17'];
          const isLabyrinthClue = state.currentMap === 'labyrinth' && LABYRINTH_CLUES.includes(key);
          const isSecretDoor = state.currentMap === 'labyrinth' && key === '15,9';

          if (lore) {
            let newState = { ...state, examineText: lore };

            // Track clue discovery
            if (isLabyrinthClue && !state.cluesFound.includes(key)) {
              const newClues = [...state.cluesFound, key];
              newState.cluesFound = newClues;

              // All 4 clues found - reveal secret door
              if (newClues.length >= 4) {
                newState.secretDoorRevealed = true;
                newState.saveNotification = 'Something shifts in the labyrinth...';
                // Append hint to current lore text
                newState.examineText = {
                  ...newState.examineText,
                  lines: [...(newState.examineText.lines || []), '', '...A distant sound of grinding stone echoes through the maze.']
                };
              }
            }

            // Special lore when examining revealed secret door
            if (isSecretDoor && state.secretDoorRevealed) {
              newState.examineText = {
                name: 'Hidden Chamber',
                lines: [
                  'The wall yields to your knowledge.',
                  '',
                  'A hidden chamber opens before you.'
                ]
              };
              // Award title for discovering the secret
              if (!state.titles.includes('ashen_seeker')) {
                newState.titles = [...state.titles, 'ashen_seeker'];
                newState.activeTitle = 'ashen_seeker';
                newState.saveNotification = 'Title earned: Ashen Seeker';
              }
            }

            return newState;
          }
          return state;
        }

        case 'CLOSE_EXAMINE': {
          return {
            ...state,
            examineText: null
          };
        }

        case 'MOVE_PLAYER': {
          const map = state.currentMap === 'ashenPath' ? ASHEN_PATH :
                      state.currentMap === 'hollowDeep' ? HOLLOW_DEEP :
                      state.currentMap === 'labyrinth' ? LABYRINTH : FALLEN_KEEP;
          const newX = state.playerPos.x + action.dx;
          const newY = state.playerPos.y + action.dy;

          // Determine direction
          let dir = state.playerDir;
          if (action.dy < 0) dir = 'up';
          else if (action.dy > 0) dir = 'down';
          else if (action.dx < 0) dir = 'left';
          else if (action.dx > 0) dir = 'right';

          if (newY < 0 || newY >= map.length || newX < 0 || newX >= map[0].length) {
            return { ...state, playerDir: dir };
          }

          const tile = map[newY][newX];

          if (tile === 'W') return { ...state, playerDir: dir };

          // Secret door blocks movement until revealed
          if (tile === 'S' && !state.secretDoorRevealed) {
            return { ...state, playerDir: dir };
          }

          // Walking into revealed secret door awards Ashen Seeker title
          if (tile === 'S' && state.secretDoorRevealed) {
            let sState = { ...state, playerPos: { x: newX, y: newY }, playerDir: dir, bonfireMenuOpen: false, withdrawMenuOpen: false, depositMenuOpen: false };
            sState.examineText = {
              name: 'The Hidden Chamber',
              lines: [
                'The wall crumbles. Beyond, a small chamber.',
                '',
                'A single flame burns in the darkness.',
                '',
                'You have found what others could not.',
                '',
                'You are an Ashen Seeker.'
              ]
            };
            if (!state.titles.includes('ashen_seeker')) {
              sState.titles = [...state.titles, 'ashen_seeker'];
              sState.activeTitle = 'ashen_seeker';
              sState.saveNotification = 'Title earned: Ashen Seeker';
            }
            return sState;
          }

          let newState = { ...state, playerPos: { x: newX, y: newY }, playerDir: dir, bonfireMenuOpen: false, withdrawMenuOpen: false, depositMenuOpen: false };

          if (tile === 'G' && (state.currentMap === 'ashenPath' || state.currentMap === 'hollowDeep' || state.currentMap === 'labyrinth')) {
            const encounter = state.grassEncounters.find(
              e => e.x === newX && e.y === newY && e.map === state.currentMap && e.active
            );
            if (encounter && !encounter.alerted && Math.random() < GAME_CONFIG.wildEncounters.grassEncounterChance) {
              const wildData = state.currentMap === 'labyrinth' ? getRandomLabyrinthWild() : state.currentMap === 'hollowDeep' ? getRandomDeepWild() : getRandomWild();
              // Apply scar penalties if pre-scarred
              let actualMaxHp = wildData.maxHp;
              let actualMaxStamina = wildData.maxStamina;
              if (wildData.scars) {
                wildData.scars.forEach(scar => {
                  if (scar.effect === 'maxHp') actualMaxHp = Math.max(15, actualMaxHp + scar.value);
                  if (scar.effect === 'maxStamina') actualMaxStamina = Math.max(8, actualMaxStamina + scar.value);
                });
              }
              // Show pre-battle preview instead of immediately starting battle
              newState = {
                ...newState,
                screen: 'encounterPreview',
                pendingEncounter: {
                  wildData,
                  actualMaxHp,
                  actualMaxStamina,
                  encounter: { x: newX, y: newY }
                }
              };
            }
          }

          if (tile === 'X') {
            newState = {
              ...newState,
              currentMap: 'fallenKeep',
              playerPos: { x: 2, y: 7 }
            };
          }

          if (tile === 'E' && state.currentMap === 'fallenKeep') {
            newState = {
              ...newState,
              currentMap: 'ashenPath',
              playerPos: { x: 2, y: 6 }
            };
          }

          if (tile === 'K' && state.currentMap === 'fallenKeep' && !state.bossDefeated) {
            const bossData = BOSS.obsidianHound;
            const difficulty = getDifficulty(state);
            const bossMaxHp = Math.floor(bossData.maxHp * difficulty.bossHpMult);
            newState = {
              ...newState,
              screen: 'battle',
              enemy: {
                ...bossData,
                maxHp: bossMaxHp,
                hp: bossMaxHp,
                stamina: bossData.maxStamina,
                winded: false,
                isGuarding: false
              },
              enemyCreature: { ...bossData, maxHp: bossMaxHp },
              battleLog: [
                'Keeper Varek blocks your path!',
                ...BOSS_DIALOGUE.intro
              ],
              turnPhase: 'player',
              bossPhase: 1,
              arenaEffect: null,
              isBossFight: true
            };
          }

          // Enter The Hollow Deep after defeating Varek
          if (tile === 'K' && state.currentMap === 'fallenKeep' && state.bossDefeated && !state.hollowWardenDefeated) {
            newState = {
              ...newState,
              currentMap: 'hollowDeep',
              playerPos: { x: 3, y: 7 }
            };
          }

          // Exit The Hollow Deep back to Fallen Keep
          if (tile === 'E' && state.currentMap === 'hollowDeep') {
            newState = {
              ...newState,
              currentMap: 'fallenKeep',
              playerPos: { x: 1, y: 6 }
            };
          }

          // Enter The Labyrinth from Hollow Deep (X tile at 8,14)
          if (tile === 'X' && state.currentMap === 'hollowDeep') {
            newState = {
              ...newState,
              currentMap: 'labyrinth',
              playerPos: { x: 9, y: 17 }
            };
          }

          // Exit The Labyrinth back to Hollow Deep (E tile at 9,18)
          if (tile === 'E' && state.currentMap === 'labyrinth') {
            newState = {
              ...newState,
              currentMap: 'hollowDeep',
              playerPos: { x: 8, y: 13 }
            };
          }

          // Hollow Warden boss fight
          if (tile === 'K' && state.currentMap === 'hollowDeep' && !state.hollowWardenDefeated) {
            const bossData = BOSS.hollowWarden;
            const difficulty = getDifficulty(state);
            const bossMaxHp = Math.floor(bossData.maxHp * difficulty.bossHpMult);
            newState = {
              ...newState,
              screen: 'battle',
              enemy: {
                ...bossData,
                maxHp: bossMaxHp,
                hp: bossMaxHp,
                stamina: bossData.maxStamina,
                winded: false,
                isGuarding: false
              },
              enemyCreature: { ...bossData, maxHp: bossMaxHp },
              battleLog: [
                'The Hollow Warden awakens!',
                ...HOLLOW_WARDEN_DIALOGUE.intro
              ],
              turnPhase: 'player',
              bossPhase: 1,
              arenaEffect: null,
              isBossFight: true,
              isHollowWardenFight: true
            };
          }

          if (state.droppedSouls &&
              state.droppedSouls.map === state.currentMap &&
              state.droppedSouls.pos.x === newX &&
              state.droppedSouls.pos.y === newY) {
            newState = {
              ...newState,
              souls: state.souls + state.droppedSouls.amount,
              droppedSouls: null,
              battleLog: [`Recovered ${state.droppedSouls.amount} souls!`]
            };
          }

          if (state.currentMap === 'fallenKeep' && newY <= 3) {
            newState.shortcutUnlocked = true;
          }

          return newState;
        }

        case 'INTERACT_BONFIRE': {
          // Toggle bonfire menu
          return {
            ...state,
            bonfireMenuOpen: !state.bonfireMenuOpen
          };
        }

        case 'REST_AT_BONFIRE': {
          const difficulty = getDifficulty(state);

          const team = state.team.map(creature => {
            const baseData = STARTERS[creature.id];
            // Clear scars on Ashen difficulty
            const scars = difficulty.scarsHealAtBonfire ? [] : creature.scars;
            const creatureWithScars = { ...creature, scars };
            const { maxHp, maxStamina } = applyScars(creatureWithScars, baseData, difficulty.hollowedThreshold);

            // Broken difficulty: bonfire doesn't heal HP
            if (!difficulty.bonfireHeals) {
              return {
                ...creature,
                scars,
                stamina: maxStamina,
                winded: false,
                burnTurns: 0,
                poisonTurns: 0,
                chillTurns: 0
              };
            }

            return {
              ...creature,
              scars,
              hp: creature.hp === 0 ? 1 : maxHp,
              stamina: maxStamina,
              winded: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0
            };
          });

          const grassEncounters = state.grassEncounters.map(e => ({ ...e, active: true }));

          const bonfireMessages = [
            "Progress saved. Enemies respawned. Life is compromise.",
            "Rested. Ready to make the same mistakes."
          ];
          const saveMessage = difficulty.bonfireHeals
            ? bonfireMessages[Math.floor(Math.random() * bonfireMessages.length)]
            : "Progress saved. No healing. Broken mode is fun, right?";

          const newState = {
            ...state,
            team,
            grassEncounters,
            lastBonfire: { map: state.currentMap, pos: { ...state.playerPos } },
            bonfireMenuOpen: false,
            withdrawMenuOpen: false,
            depositMenuOpen: false,
            saveNotification: saveMessage
          };

          // Auto-save when resting
          saveGame(newState);

          return newState;
        }

        case 'CLEAR_NOTIFICATION': {
          return {
            ...state,
            saveNotification: null
          };
        }

        case 'SWITCH_ACTIVE_AT_BONFIRE': {
          // Can only switch to creatures with HP > 0
          const targetCreature = state.team[action.index];
          if (!targetCreature || targetCreature.hp <= 0) {
            return state;
          }
          return {
            ...state,
            activeCreatureIndex: action.index,
            bonfireMenuOpen: false
          };
        }

        case 'CLOSE_BONFIRE_MENU': {
          return {
            ...state,
            bonfireMenuOpen: false,
            withdrawMenuOpen: false,
            depositMenuOpen: false
          };
        }

        case 'TOGGLE_WITHDRAW_MENU': {
          return {
            ...state,
            withdrawMenuOpen: !state.withdrawMenuOpen,
            depositMenuOpen: false
          };
        }

        case 'WITHDRAW_SOULS': {
          const amount = Math.min(action.amount, state.bankedSouls);
          if (amount <= 0) return state;
          const newState = {
            ...state,
            souls: state.souls + amount,
            bankedSouls: state.bankedSouls - amount
          };
          saveGame(newState);
          return newState;
        }

        case 'TOGGLE_DEPOSIT_MENU': {
          return {
            ...state,
            depositMenuOpen: !state.depositMenuOpen,
            withdrawMenuOpen: false
          };
        }

        case 'DEPOSIT_SOULS': {
          const amount = Math.min(action.amount, state.souls);
          if (amount <= 0) return state;
          const newState = {
            ...state,
            souls: state.souls - amount,
            bankedSouls: state.bankedSouls + amount
          };
          saveGame(newState);
          return newState;
        }

        case 'SELECT_MOVE': {
          const activeCreature = state.team[state.activeCreatureIndex];
          // Check Flinching scar - strip priority at resolution time
          const { hasFlinching } = applyScars(activeCreature, STARTERS[activeCreature.id]);
          const move = action.move.priority && hasFlinching ? { ...action.move, priority: false } : action.move;

          if (move.cost > activeCreature.stamina) return state;

          let newTeam = [...state.team];
          let newEnemy = { ...state.enemy };
          let log = [...state.battleLog];
          let turnPhase = 'enemy';

          if (move.effect === 'rest') {
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              stamina: Math.min(activeCreature.stamina + GAME_CONFIG.combat.restRecoveryBase + GAME_CONFIG.combat.staminaPerTurnRecovery,
                applyScars(activeCreature, STARTERS[activeCreature.id]).maxStamina),
              winded: false,
              isGuarding: false
            };
            log.push(`${activeCreature.nickname || activeCreature.name} rests and recovers stamina.`);
            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          // Purifying Light - removes all status effects and heals
          if (move.effect === 'purify') {
            const baseData = STARTERS[activeCreature.id];
            const { maxHp } = applyScars(activeCreature, baseData);
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              hp: Math.min(activeCreature.hp + (move.healAmount || GAME_CONFIG.fallbacks.healAmount), maxHp),
              stamina: activeCreature.stamina - move.cost,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              winded: false,
              isGuarding: false
            };
            log.push(`${activeCreature.nickname || activeCreature.name} used ${move.name}!`);
            log.push(`${activeCreature.nickname || activeCreature.name} is purified and healed!`);
            if (newTeam[state.activeCreatureIndex].stamina < GAME_CONFIG.combat.windedThreshold) {
              newTeam[state.activeCreatureIndex].winded = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
            }
            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          if (move.effect === 'guard') {
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              stamina: activeCreature.stamina - move.cost,
              isGuarding: true
            };
            log.push(`${activeCreature.nickname || activeCreature.name} takes a defensive stance.`);

            if (activeCreature.stamina - move.cost < GAME_CONFIG.combat.windedThreshold) {
              newTeam[state.activeCreatureIndex].winded = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
            }

            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          const damage = calculateDamage(move, activeCreature, newEnemy,
            STARTERS[activeCreature.id], state.enemyCreature);

          newEnemy.hp = Math.max(0, newEnemy.hp - damage);
          newEnemy.isGuarding = false;

          const effectiveness = TYPE_CHART[STARTERS[activeCreature.id].type][state.enemyCreature.type];
          let effectText = '';
          if (effectiveness > 1) effectText = " It's super effective!";
          if (effectiveness < 1) effectText = " It's not very effective...";

          log.push(`${activeCreature.nickname || activeCreature.name} used ${move.name}! ${damage} damage.${effectText}`);

          // Apply status effects to enemy based on move
          if (move.effect && move.effectChance && Math.random() * 100 < move.effectChance) {
            if (move.effect === 'burn' && (!newEnemy.burnTurns || newEnemy.burnTurns === 0)) {
              newEnemy.burnTurns = GAME_CONFIG.statusFx.burnDuration;
              log.push(`${state.enemyCreature.name} is burning!`);
            }
            if (move.effect === 'poison' && (!newEnemy.poisonTurns || newEnemy.poisonTurns === 0)) {
              newEnemy.poisonTurns = GAME_CONFIG.statusFx.poisonDuration;
              log.push(`${state.enemyCreature.name} is poisoned!`);
            }
            if (move.effect === 'chill' && (!newEnemy.chillTurns || newEnemy.chillTurns === 0)) {
              newEnemy.chillTurns = GAME_CONFIG.statusFx.chillDuration;
              log.push(`${state.enemyCreature.name} is chilled!`);
            }
          }

          // Void Drain - drains stamina from enemy and heals self
          if (move.effect === 'drain') {
            const drainAmount = move.drainStamina || GAME_CONFIG.fallbacks.drainStamina;
            const healAmount = move.drainHp || GAME_CONFIG.fallbacks.drainHp;
            newEnemy.stamina = Math.max(0, newEnemy.stamina - drainAmount);
            const baseData = STARTERS[activeCreature.id];
            const { maxHp } = applyScars(activeCreature, baseData);
            newTeam[state.activeCreatureIndex] = {
              ...newTeam[state.activeCreatureIndex],
              hp: Math.min(activeCreature.hp + healAmount, maxHp)
            };
            log.push(`${activeCreature.nickname || activeCreature.name} drains ${drainAmount} stamina and heals ${healAmount} HP!`);
          }

          newTeam[state.activeCreatureIndex] = {
            ...newTeam[state.activeCreatureIndex],
            stamina: activeCreature.stamina - move.cost,
            isGuarding: false
          };

          if (newTeam[state.activeCreatureIndex].stamina < GAME_CONFIG.combat.windedThreshold) {
            newTeam[state.activeCreatureIndex].winded = true;
            log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
          }

          if (state.isBossFight && state.bossPhase === 1 &&
              newEnemy.hp <= state.enemyCreature.maxHp * GAME_CONFIG.bosses.phaseTransitionThreshold && newEnemy.hp > 0) {
            const difficulty = getDifficulty(state);
            // Broken difficulty: no phase transition pause (boss still transforms but no HP recovery)
            if (difficulty.bossPhaseTransition) {
              newEnemy.hp += state.isHollowWardenFight ? GAME_CONFIG.bosses.hollowWardenPhaseHeal : GAME_CONFIG.bosses.obsidianHoundPhaseHeal;
            }

            if (state.isHollowWardenFight) {
              HOLLOW_WARDEN_DIALOGUE.phase2.forEach(line => log.push(line));
              log.push('The Hollow Warden fractures! Light and dark merge into chaos!');
              return {
                ...state,
                team: newTeam,
                enemy: newEnemy,
                enemyCreature: { ...state.enemyCreature, type: 'darklight' },
                battleLog: log,
                bossPhase: 2,
                arenaEffect: 'fracturedAura',
                turnPhase
              };
            } else {
              BOSS_DIALOGUE.phase2.forEach(line => log.push(line));
              log.push('Obsidian Hound transforms! The arena ignites with scorched earth!');
              return {
                ...state,
                team: newTeam,
                enemy: newEnemy,
                battleLog: log,
                bossPhase: 2,
                arenaEffect: 'scorchedEarth',
                turnPhase
              };
            }
          }

          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);

            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }

            const grassEncounters = state.grassEncounters.map(e =>
              e.x === state.currentEncounter?.x && e.y === state.currentEncounter?.y
                ? { ...e, active: false }
                : e
            );

            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              enemyCreature: null,
              team: newTeam,
              battleLog: log,
              grassEncounters
            };
          }

          return { ...state, team: newTeam, enemy: newEnemy, battleLog: log, turnPhase };
        }

        case 'BIND_ATTEMPT': {
          // Can't bind bosses
          if (state.isBossFight) {
            return { ...state, battleLog: [...state.battleLog, "Can't bind a boss!"] };
          }

          // Check if can afford
          if (state.souls < GAME_CONFIG.souls.bindCost) {
            return { ...state, battleLog: [...state.battleLog, "Not enough souls!"] };
          }

          let log = [...state.battleLog];
          const difficulty = getDifficulty(state);
          const captureChance = getCaptureChance(state.enemy.hp, state.enemy.maxHp, difficulty.captureBonus);
          const roll = Math.random() * 100;

          log.push(`Attempting soul bind... (${captureChance}% chance)`);

          // Deduct souls regardless of outcome
          const newSouls = state.souls - GAME_CONFIG.souls.bindCost;

          if (roll < captureChance) {
            // SUCCESS! Creature captured
            const capturedCreature = {
              id: state.enemyCreature.id.replace('wild', '').toLowerCase(),
              name: state.enemyCreature.name.replace('Wild ', ''),
              type: state.enemyCreature.type,
              maxHp: state.enemy.maxHp,
              maxStamina: state.enemy.maxStamina,
              hp: state.enemy.hp,
              stamina: state.enemy.stamina,
              scars: state.enemy.scars || [],
              winded: false,
              isGuarding: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              moves: []
            };

            // Fix the id and moves to match STARTERS based on type
            const typeToStarter = {
              fire: 'cindrath',
              water: 'marshveil',
              grass: 'thornwick',
              dark: 'umbravine',
              light: 'solrath'
            };
            capturedCreature.id = typeToStarter[state.enemyCreature.type] || 'cindrath';
            capturedCreature.moves = STARTERS[capturedCreature.id].moves;
            capturedCreature.nickname = null; // Will be set in nickname screen

            const grassEncounters = state.grassEncounters.map(e =>
              e.x === state.currentEncounter?.x && e.y === state.currentEncounter?.y
                ? { ...e, active: false }
                : e
            );

            // Team full? Show release screen instead of nickname
            if (state.team.length >= GAME_CONFIG.souls.maxTeamSize) {
              log.push(`${capturedCreature.name} bound! But your team is full...`);
              return {
                ...state,
                screen: 'release',
                pendingCapture: capturedCreature,
                releaseMenuOpen: true,
                souls: newSouls,
                battleLog: log,
                grassEncounters
              };
            }

            // Team has room - go straight to nickname
            log.push(state.playerName
              ? `${capturedCreature.name} answered ${state.playerName}'s call!`
              : `${capturedCreature.name} answered your call!`);
            return {
              ...state,
              screen: 'nickname',
              pendingCreature: capturedCreature,
              souls: newSouls,
              battleLog: log,
              grassEncounters
            };
          } else {
            // FAILED - enemy gets a free attack
            const failMessages = [
              "They said no. Respect boundaries.",
              state.playerName ? `${state.playerName}'s call went unanswered.` : "Your call went unanswered.",
              "The binding failed. They resist."
            ];
            log.push(failMessages[Math.floor(Math.random() * failMessages.length)]);

            // Enemy retaliates
            return {
              ...state,
              souls: newSouls,
              battleLog: log,
              turnPhase: 'enemy'
            };
          }
        }

        case 'RELEASE_FOR_CAPTURE': {
          if (!state.pendingCapture) return state;
          if (action.releaseIndex < 0 || action.releaseIndex >= state.team.length) return state;

          const releasedCreature = state.team[action.releaseIndex];
          const newTeam = state.team.filter((_, i) => i !== action.releaseIndex);

          // Adjust activeCreatureIndex if needed
          let newActiveIndex = state.activeCreatureIndex;
          if (action.releaseIndex < state.activeCreatureIndex) {
            newActiveIndex = state.activeCreatureIndex - 1;
          } else if (action.releaseIndex === state.activeCreatureIndex) {
            newActiveIndex = 0;
          }

          return {
            ...state,
            screen: 'nickname',
            team: newTeam,
            activeCreatureIndex: Math.min(newActiveIndex, newTeam.length - 1),
            pendingCreature: state.pendingCapture,
            pendingCapture: null,
            releaseMenuOpen: false,
            battleLog: [...state.battleLog, `${releasedCreature.nickname || releasedCreature.name} was released forever.`]
          };
        }

        case 'CANCEL_CAPTURE': {
          if (!state.pendingCapture) return state;

          return {
            ...state,
            screen: 'exploration',
            pendingCapture: null,
            releaseMenuOpen: false,
            enemy: null,
            enemyCreature: null,
            battleLog: [...state.battleLog, `${state.pendingCapture.name} escaped while you hesitated.`]
          };
        }

        case 'SET_NICKNAME': {
          if (!state.pendingCreature) return state;

          const creature = {
            ...state.pendingCreature,
            nickname: action.nickname || null
          };

          return {
            ...state,
            screen: 'exploration',
            team: [...state.team, creature],
            pendingCreature: null,
            enemy: null,
            enemyCreature: null
          };
        }

        case 'RENAME_CREATURE': {
          const newTeam = [...state.team];
          newTeam[action.index] = {
            ...newTeam[action.index],
            nickname: action.nickname || null
          };
          return {
            ...state,
            team: newTeam
          };
        }


        case 'ENEMY_TURN': {
          let newTeam = [...state.team];
          let newEnemy = { ...state.enemy };
          let log = [...state.battleLog];
          let activeCreature = newTeam[state.activeCreatureIndex];
          const activeBase = STARTERS[activeCreature.id];
          const enemyDifficulty = getDifficulty(state);
          const { maxHp, maxStamina } = applyScars(activeCreature, activeBase, enemyDifficulty.hollowedThreshold);

          activeCreature = {
            ...activeCreature,
            stamina: Math.min(activeCreature.stamina + GAME_CONFIG.combat.staminaPerTurnRecovery, maxStamina)
          };

          if (activeCreature.stamina >= GAME_CONFIG.combat.windedThreshold) {
            activeCreature.winded = false;
          }

          // Process burn damage
          if (activeCreature.burnTurns > 0) {
            activeCreature.hp = Math.max(0, activeCreature.hp - GAME_CONFIG.statusFx.burnDamage);
            activeCreature.burnTurns--;
            log.push(`${activeCreature.nickname || activeCreature.name} takes ${GAME_CONFIG.statusFx.burnDamage} burn damage!`);
          }

          // Process poison damage
          if (activeCreature.poisonTurns > 0) {
            activeCreature.hp = Math.max(0, activeCreature.hp - GAME_CONFIG.statusFx.poisonDamage);
            activeCreature.poisonTurns--;
            log.push(`${activeCreature.nickname || activeCreature.name} takes ${GAME_CONFIG.statusFx.poisonDamage} poison damage!`);
          }

          // Process chill effect
          let chillSkip = false;
          if (activeCreature.chillTurns > 0) {
            activeCreature.chillTurns--;
            if (Math.random() < GAME_CONFIG.statusFx.chillSkipChance) {
              chillSkip = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is frozen and can't move!`);
            }
          }

          if (state.arenaEffect === 'scorchedEarth' && activeBase.type !== 'fire') {
            activeCreature.hp = Math.max(0, activeCreature.hp - GAME_CONFIG.statusFx.scorchedEarthDamage);
            log.push(`Scorched Earth burns ${activeCreature.nickname || activeCreature.name} for ${GAME_CONFIG.statusFx.scorchedEarthDamage} damage!`);
          }

          // Fractured Aura damages non-Dark/Light creatures
          if (state.arenaEffect === 'fracturedAura' && activeBase.type !== 'dark' && activeBase.type !== 'light') {
            activeCreature.hp = Math.max(0, activeCreature.hp - GAME_CONFIG.statusFx.fracturedAuraDamage);
            log.push(`Fractured Aura tears at ${activeCreature.nickname || activeCreature.name} for ${GAME_CONFIG.statusFx.fracturedAuraDamage} damage!`);
          }

          newTeam[state.activeCreatureIndex] = activeCreature;

          if (activeCreature.hp <= 0) {
            return handleCreatureFaint(state, newTeam, newEnemy, log);
          }

          newEnemy.stamina = Math.min(newEnemy.stamina + GAME_CONFIG.combat.staminaPerTurnRecovery, state.enemyCreature.maxStamina);
          newEnemy.winded = false;

          // Process enemy status effects
          if (newEnemy.burnTurns > 0) {
            newEnemy.hp = Math.max(0, newEnemy.hp - GAME_CONFIG.statusFx.burnDamage);
            newEnemy.burnTurns--;
            log.push(`${state.enemyCreature.name} takes ${GAME_CONFIG.statusFx.burnDamage} burn damage!`);
          }
          if (newEnemy.poisonTurns > 0) {
            newEnemy.hp = Math.max(0, newEnemy.hp - GAME_CONFIG.statusFx.poisonDamage);
            newEnemy.poisonTurns--;
            log.push(`${state.enemyCreature.name} takes ${GAME_CONFIG.statusFx.poisonDamage} poison damage!`);
          }

          // Check if enemy died from status effects
          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);
            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }
            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              team: newTeam,
              battleLog: log
            };
          }

          // Get available moves based on boss type and phase
          let bossData = state.isHollowWardenFight ? BOSS.hollowWarden : BOSS.obsidianHound;
          let availableMoves = (state.bossPhase === 2 ?
            bossData.phase2Moves : state.enemyCreature.moves)
            .filter(m => m.cost <= newEnemy.stamina);

          if (availableMoves.length === 0) {
            availableMoves = [{ name: 'Rest', cost: 0, damage: 0, effect: 'rest' }];
          }

          let selectedMove;
          if (state.isBossFight) {
            const playerHpPercent = activeCreature.hp / (maxHp || 1);
            if (state.isHollowWardenFight) {
              // Hollow Warden AI
              if (state.bossPhase === 2 && playerHpPercent < 0.4) {
                const despVoid = availableMoves.find(m => m.name === 'Desperate Void');
                if (despVoid) selectedMove = despVoid;
              }
              if (!selectedMove && activeCreature.stamina > 12) {
                const voidGrasp = availableMoves.find(m => m.name === 'Void Grasp');
                if (voidGrasp) selectedMove = voidGrasp;
              }
            } else {
              // Obsidian Hound AI
              if (state.bossPhase === 2 && playerHpPercent < 0.4) {
                const despFang = availableMoves.find(m => m.name === 'Desperation Fang');
                if (despFang) selectedMove = despFang;
              }
              if (!selectedMove && playerHpPercent > 0.7) {
                const flameWall = availableMoves.find(m => m.name === 'Flame Wall');
                if (flameWall) selectedMove = flameWall;
              }
            }
          }

          if (!selectedMove) {
            const attackMoves = availableMoves.filter(m => m.damage > 0);
            selectedMove = attackMoves.length > 0
              ? attackMoves[Math.floor(Math.random() * attackMoves.length)]
              : availableMoves[0];
          }

          if (selectedMove.effect === 'rest') {
            newEnemy.stamina = Math.min(newEnemy.stamina + GAME_CONFIG.combat.restRecoveryBase + GAME_CONFIG.combat.staminaPerTurnRecovery, state.enemyCreature.maxStamina);
            log.push(`${state.enemyCreature.name} rests.`);
          } else if (selectedMove.effect === 'guard') {
            newEnemy.isGuarding = true;
            newEnemy.stamina -= selectedMove.cost;
            log.push(`${state.enemyCreature.name} guards.`);
          } else {
            const difficulty = getDifficulty(state);
            const damageMult = state.isBossFight ? difficulty.bossDamageMult : difficulty.wildDamageMult;
            const damage = calculateDamage(selectedMove, newEnemy, activeCreature,
              state.enemyCreature, activeBase, damageMult);

            activeCreature.hp = Math.max(0, activeCreature.hp - damage);
            activeCreature.isGuarding = false;
            newEnemy.stamina -= selectedMove.cost;

            log.push(`${state.enemyCreature.name} used ${selectedMove.name}! ${damage} damage.`);

            // Apply status effects from enemy attacks
            if (selectedMove.effect === 'burn' && (!activeCreature.burnTurns || activeCreature.burnTurns === 0)) {
              activeCreature.burnTurns = GAME_CONFIG.statusFx.burnDuration;
              log.push(`${activeCreature.nickname || activeCreature.name} is burning!`);
            }
            if (selectedMove.effect === 'poison' && (!activeCreature.poisonTurns || activeCreature.poisonTurns === 0)) {
              activeCreature.poisonTurns = GAME_CONFIG.statusFx.poisonDuration;
              log.push(`${activeCreature.nickname || activeCreature.name} is poisoned!`);
            }
            if (selectedMove.effect === 'chill' && (!activeCreature.chillTurns || activeCreature.chillTurns === 0)) {
              activeCreature.chillTurns = GAME_CONFIG.statusFx.chillDuration;
              log.push(`${activeCreature.nickname || activeCreature.name} is chilled!`);
            }

            if (selectedMove.effect === 'recoil') {
              newEnemy.hp = Math.max(0, newEnemy.hp - selectedMove.recoilDamage);
              log.push(`${state.enemyCreature.name} takes ${selectedMove.recoilDamage} recoil!`);
            }

            // Void Grasp drains stamina
            if (selectedMove.effect === 'drainStamina') {
              activeCreature.stamina = Math.max(0, activeCreature.stamina - selectedMove.drainAmount);
              log.push(`${activeCreature.nickname || activeCreature.name} loses ${selectedMove.drainAmount} stamina!`);
            }

            if (newEnemy.stamina < GAME_CONFIG.combat.windedThreshold) {
              newEnemy.winded = true;
              log.push(`${state.enemyCreature.name} is winded!`);
            }
          }

          newTeam[state.activeCreatureIndex] = activeCreature;

          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);

            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }

            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              team: newTeam,
              battleLog: log
            };
          }

          if (activeCreature.hp <= 0) {
            return handleCreatureFaint(state, newTeam, newEnemy, log);
          }

          return {
            ...state,
            team: newTeam,
            enemy: newEnemy,
            battleLog: log,
            turnPhase: 'player'
          };
        }

        case 'SWITCH_CREATURE': {
          if (state.team[action.index].hp <= 0) return state;
          return {
            ...state,
            activeCreatureIndex: action.index,
            battleLog: [...state.battleLog, `Go, ${state.team[action.index].name}!`]
          };
        }

        case 'RESPAWN': {
          const respawnDifficulty = getDifficulty(state);
          const team = state.team.map(creature => {
            const baseData = STARTERS[creature.id];
            const { maxHp, maxStamina } = applyScars(creature, baseData, respawnDifficulty.hollowedThreshold);
            return {
              ...creature,
              hp: creature.hp === 0 ? 1 : Math.max(creature.hp, 1),
              stamina: maxStamina,
              winded: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              isGuarding: false
            };
          });

          return {
            ...state,
            screen: 'exploration',
            currentMap: state.lastBonfire.map,
            playerPos: { ...state.lastBonfire.pos },
            team,
            activeCreatureIndex: Math.max(0, team.findIndex(c => c.hp > 0)),
            enemy: null,
            enemyCreature: null,
            battleLog: [],
            turnPhase: 'player',
            bossPhase: 1,
            arenaEffect: null,
            isBossFight: false,
            diedToBoss: false,
            bonfireMenuOpen: false,
            withdrawMenuOpen: false,
            depositMenuOpen: false
          };
        }

        case 'RESTART': {
          return {
            ...initialState,
            hasSeenPrologue: true // Skip prologue on subsequent playthroughs
          };
        }

        case 'SHOW_CREDITS': {
          return {
            ...state,
            screen: 'credits'
          };
        }

        case 'RETURN_TO_TITLE': {
          return initialState;
        }

        case 'MANUAL_SAVE': {
          const success = saveGame(state);
          return {
            ...state,
            saveNotification: success ? 'Progress saved.' : 'Save failed!'
          };
        }

        case 'LOAD_GAME': {
          const saveData = action.saveData;
          if (!saveData) return state;

          return {
            ...initialState,
            screen: 'exploration',
            difficulty: saveData.difficulty || 'scarred',
            playerName: saveData.playerName || 'Ashen One',
            playerAppearance: saveData.playerAppearance || 'other',
            currentMap: saveData.currentMap,
            playerPos: saveData.playerPos,
            playerDir: saveData.playerDir,
            team: saveData.team,
            activeCreatureIndex: saveData.activeCreatureIndex,
            souls: saveData.souls,
            bankedSouls: saveData.bankedSouls,
            droppedSouls: saveData.droppedSouls,
            bossDefeated: saveData.bossDefeated,
            hollowWardenDefeated: saveData.hollowWardenDefeated || false,
            shortcutUnlocked: saveData.shortcutUnlocked,
            grassEncounters: saveData.grassEncounters,
            lastBonfire: saveData.lastBonfire,
            hasSeenPrologue: saveData.hasSeenPrologue,
            playTime: saveData.playTime || 0,
            titles: saveData.titles || [],
            activeTitle: saveData.activeTitle || null,
            cluesFound: saveData.cluesFound || [],
            secretDoorRevealed: saveData.secretDoorRevealed || false,
            saveNotification: 'Journey resumed.'
          };
        }

        case 'NEW_GAME_CONFIRMED': {
          deleteSaveData();
          return initialState;
        }

        case 'UPDATE_PLAY_TIME': {
          return {
            ...state,
            playTime: state.playTime + action.delta
          };
        }

        case 'EARN_TITLE': {
          const titleId = action.titleId;
          if (state.titles.includes(titleId)) {
            return state;
          }
          const titleData = TITLES.find(t => t.id === titleId);
          const titleName = titleData ? titleData.name : titleId;
          return {
            ...state,
            titles: [...state.titles, titleId],
            saveNotification: `Title earned: ${titleName}`
          };
        }

        case 'SET_ACTIVE_TITLE': {
          return {
            ...state,
            activeTitle: action.titleId
          };
        }

        case 'CONFIRM_ENCOUNTER': {
          if (!state.pendingEncounter) return state;
          const { wildData, actualMaxHp, actualMaxStamina, encounter } = state.pendingEncounter;
          return {
            ...state,
            screen: 'battle',
            enemy: {
              ...wildData,
              maxHp: actualMaxHp,
              maxStamina: actualMaxStamina,
              hp: actualMaxHp,
              stamina: actualMaxStamina,
              winded: false,
              isGuarding: false
            },
            enemyCreature: wildData,
            battleLog: [`A ${wildData.name} appeared!`],
            turnPhase: 'player',
            currentEncounter: encounter,
            pendingEncounter: null
          };
        }

        case 'FLEE_ENCOUNTER': {
          if (!state.pendingEncounter) return state;
          const { encounter } = state.pendingEncounter;
          // Mark grass as alerted - can't flee twice
          const grassEncounters = state.grassEncounters.map(e =>
            e.x === encounter.x && e.y === encounter.y && e.map === state.currentMap
              ? { ...e, alerted: true }
              : e
          );
          return {
            ...state,
            screen: 'exploration',
            pendingEncounter: null,
            grassEncounters
          };
        }

        default:
          return state;
      }
    }

    // ============= REACT UI COMPONENTS =============
    function DifficultySelect({ dispatch, onShowStats, onShowFallen }) {
      const difficultyInfo = {
        ashen: [
          ' Wild damage reduced 50%',
          ' Scars heal at bonfire',
          ' Souls only drop 50% on death',
          ' Capture chance +20%'
        ],
        scarred: [
          ' Standard damage (wild -25%)',
          ' Permanent scars',
          ' Full soul drop on death',
          ' Standard capture rates'
        ],
        hollowed: [
          ' Full damage from all enemies',
          ' Worse scar penalties (-7 HP, -3 STA)',
          ' Drop ALL souls including banked',
          ' Capture chance -20%',
          ' Boss has 25% more HP'
        ],
        broken: [
          ' All Hollowed settings plus:',
          ' No bonfire healing (save only)',
          ' One scar = Hollowed status',
          ' Boss has no phase pause',
          ' PERMADEATH: Save deleted on wipe'
        ]
      };

      return (
        <div style={styles.difficultySelect}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>SCARS OF ASH</h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)', fontStyle: 'italic' }}>The flame remembers.</div>
          <div style={styles.difficultyTitle}>CHOOSE YOUR FATE</div>

          {Object.values(DIFFICULTIES).map(diff => (
            <div
              key={diff.id}
              style={styles.difficultyCard}
              onClick={() => dispatch({ type: 'SELECT_DIFFICULTY', difficulty: diff.id })}
              onMouseOver={e => {
                const colors = { ashen: GBC.gold, scarred: GBC.textDim, hollowed: GBC.red, broken: '#8b0000' };
                e.currentTarget.style.borderColor = colors[diff.id] || GBC.border;
              }}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              <div style={styles.difficultyHeader}>
                <span style={styles.difficultyIcon}>{diff.icon}</span>
                <span style={styles.difficultyName}>{diff.name}</span>
                <span style={styles.difficultySubtitle}>({diff.subtitle})</span>
              </div>
              <div style={styles.difficultyDesc}>"{diff.description}"</div>
              <div style={styles.difficultyDetails}>
                {difficultyInfo[diff.id].map((line, i) => (
                  <div key={i}>{line}</div>
                ))}
              </div>
            </div>
          ))}

          <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center', marginTop: 'var(--spacing-lg)', flexWrap: 'wrap' }}>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)'
              }}
              onClick={onShowStats}
            >
              STATS
            </button>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)',
                borderColor: GBC.red,
                color: GBC.red
              }}
              onClick={onShowFallen}
            >
              MEMORIAL
            </button>
          </div>
        </div>
      );
    }

    function DifficultyIndicator({ difficulty }) {
      const diff = DIFFICULTIES[difficulty] || DIFFICULTIES.scarred;
      return (
        <div style={styles.difficultyIndicator}>
          <span>{diff.icon}</span>
          <span style={styles.difficultyIndicatorName}>{diff.name}</span>
        </div>
      );
    }

    function CharacterCreate({ dispatch }) {
      const [name, setName] = useState('');
      const [appearance, setAppearance] = useState('');

      const isValid = name.trim().length > 0 && appearance;

      const appearances = [
        { id: 'male', label: 'MALE' },
        { id: 'female', label: 'FEMALE' },
        { id: 'other', label: 'OTHER' }
      ];

      return (
        <div style={{
          textAlign: 'center',
          padding: 'var(--spacing-lg)',
          maxWidth: '400px',
          margin: '0 auto'
        }}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>
            SCARS OF ASH
          </h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-xl)', fontStyle: 'italic' }}>
            "The flame remembers."
          </div>

          <div style={{
            color: GBC.textDim,
            fontSize: 'var(--font-lg)',
            marginBottom: 'var(--spacing-lg)',
            letterSpacing: '2px'
          }}>
            WHO ARE YOU?
          </div>

          {/* Name input */}
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value.slice(0, 12))}
              placeholder="Enter your name"
              maxLength={12}
              style={{
                width: '100%',
                maxWidth: '280px',
                padding: 'var(--spacing-md)',
                backgroundColor: GBC.bgPanel,
                border: `3px solid ${GBC.border}`,
                color: GBC.text,
                fontFamily: '"Press Start 2P", monospace',
                fontSize: 'var(--font-sm)',
                textAlign: 'center',
                outline: 'none',
                boxSizing: 'border-box'
              }}
              onFocus={(e) => e.target.style.borderColor = GBC.gold}
              onBlur={(e) => e.target.style.borderColor = GBC.border}
            />
            <div style={{
              color: GBC.textDim,
              fontSize: 'var(--font-xs)',
              marginTop: 'var(--spacing-xs)'
            }}>
              {name.length}/12
            </div>
          </div>

          {/* Appearance selection */}
          <div style={{
            display: 'flex',
            justifyContent: 'center',
            gap: 'var(--spacing-md)',
            marginBottom: 'var(--spacing-xl)',
            flexWrap: 'wrap'
          }}>
            {appearances.map(opt => (
              <div
                key={opt.id}
                onClick={() => setAppearance(opt.id)}
                style={{
                  padding: 'var(--spacing-md)',
                  backgroundColor: GBC.bgPanel,
                  border: `3px solid ${appearance === opt.id ? GBC.gold : GBC.border}`,
                  cursor: 'pointer',
                  minWidth: '80px',
                  transition: 'border-color 0.2s'
                }}
                onMouseOver={e => { if (appearance !== opt.id) e.currentTarget.style.borderColor = GBC.textDim; }}
                onMouseOut={e => { if (appearance !== opt.id) e.currentTarget.style.borderColor = GBC.border; }}
              >
                <div style={{
                  display: 'flex',
                  justifyContent: 'center',
                  marginBottom: 'var(--spacing-sm)'
                }}>
                  <PlayerSprite direction="down" appearance={opt.id} />
                </div>
                <div style={{
                  color: appearance === opt.id ? GBC.gold : GBC.text,
                  fontSize: 'var(--font-xs)'
                }}>
                  {opt.label}
                </div>
              </div>
            ))}
          </div>

          {/* Begin button */}
          <button
            disabled={!isValid}
            onClick={() => dispatch({ type: 'CREATE_CHARACTER', name, appearance })}
            style={{
              ...styles.button,
              padding: 'var(--spacing-md) var(--spacing-xl)',
              fontSize: 'var(--font-base)',
              opacity: isValid ? 1 : 0.5,
              cursor: isValid ? 'pointer' : 'not-allowed'
            }}
          >
            BEGIN
          </button>

          {!isValid && (
            <div style={{
              color: GBC.textDim,
              fontSize: 'var(--font-xs)',
              marginTop: 'var(--spacing-md)'
            }}>
              Enter a name and choose your appearance
            </div>
          )}
        </div>
      );
    }

    function StarterSelect({ dispatch }) {
      return (
        <div style={styles.starterSelect}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>SCARS OF ASH</h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)', fontStyle: 'italic' }}>The flame remembers.</div>
          <p style={{ color: GBC.text, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>Choose your survivor</p>
          <div>
            {Object.values(STARTERS).filter(s => ['cindrath', 'marshveil', 'thornwick'].includes(s.id)).map(starter => (
              <div
                key={starter.id}
                style={styles.starterCard}
                onClick={() => dispatch({ type: 'SELECT_STARTER', starter: starter.id })}
                onMouseOver={e => e.currentTarget.style.borderColor = getTypeColor(starter.type)}
                onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
              >
                <div style={{ display: 'flex', justifyContent: 'center', marginBottom: 'var(--spacing-sm)' }}>
                  <CreatureSprite type={starter.type} size={48} animated={false} />
                </div>
                <div style={{ margin: 'var(--spacing-sm) 0 var(--spacing-xs)', color: GBC.text, fontSize: 'var(--font-base)' }}>{starter.name}</div>
                <div style={{ fontSize: 'var(--font-sm)', color: getTypeColor(starter.type), margin: 'var(--spacing-xs) 0' }}>
                  {starter.type.toUpperCase()}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                  HP {starter.maxHp}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                  STA {starter.maxStamina}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: getTypeColor(starter.type), marginTop: 'var(--spacing-xs)' }}>
                  {starter.moves[0].name}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function Exploration({ state, dispatch }) {
      const map = state.currentMap === 'ashenPath' ? ASHEN_PATH : state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : state.currentMap === 'labyrinth' ? LABYRINTH : FALLEN_KEEP;
      const mapName = state.currentMap === 'ashenPath' ? 'Ashen Path' : state.currentMap === 'hollowDeep' ? 'The Hollow Deep' : state.currentMap === 'labyrinth' ? 'The Labyrinth' : 'Fallen Keep';
      const ghost = loadGhost(); // Load once for ghost marker display

      // Track movement for walk animation
      const [isMoving, setIsMoving] = useState(false);
      const prevPosRef = useRef({ x: state.playerPos.x, y: state.playerPos.y });
      const moveTimeoutRef = useRef(null);
      const autoPathRef = useRef(null);
      const [destFlash, setDestFlash] = useState(null);

      // Cancel any active auto-path
      const cancelAutoPath = useCallback(() => {
        if (autoPathRef.current) {
          clearTimeout(autoPathRef.current.timerId);
          autoPathRef.current = null;
        }
        setDestFlash(null);
      }, []);

      // Detect when player position changes and trigger walk animation
      useEffect(() => {
        const posChanged = prevPosRef.current.x !== state.playerPos.x ||
                          prevPosRef.current.y !== state.playerPos.y;

        if (posChanged) {
          setIsMoving(true);
          prevPosRef.current = { x: state.playerPos.x, y: state.playerPos.y };

          // Clear any existing timeout
          if (moveTimeoutRef.current) {
            clearTimeout(moveTimeoutRef.current);
          }

          // Stop moving animation after 200ms of no movement
          moveTimeoutRef.current = setTimeout(() => {
            setIsMoving(false);
          }, 200);
        }

        return () => {
          if (moveTimeoutRef.current) {
            clearTimeout(moveTimeoutRef.current);
          }
        };
      }, [state.playerPos.x, state.playerPos.y]);

      // Auto-path: walk tile-by-tile to a tapped destination
      const startAutoPath = useCallback((path) => {
        cancelAutoPath();
        if (path.length === 0) return;
        const dest = path[path.length - 1];
        setDestFlash({ x: dest.x, y: dest.y });

        // Pre-compute dx/dy steps from current position through path
        const steps = [];
        let prevX = state.playerPos.x;
        let prevY = state.playerPos.y;
        for (let i = 0; i < path.length; i++) {
          steps.push({ dx: path[i].x - prevX, dy: path[i].y - prevY });
          prevX = path[i].x;
          prevY = path[i].y;
        }

        autoPathRef.current = { steps: steps, stepIndex: 0, timerId: null };

        const executeNextStep = () => {
          const ap = autoPathRef.current;
          if (!ap || ap.stepIndex >= ap.steps.length) {
            // Done walking
            autoPathRef.current = null;
            setDestFlash(null);
            return;
          }
          const step = ap.steps[ap.stepIndex];
          dispatch({ type: 'MOVE_PLAYER', dx: step.dx, dy: step.dy });
          ap.stepIndex++;
          if (ap.stepIndex < ap.steps.length) {
            ap.timerId = setTimeout(executeNextStep, 150);
          } else {
            // Final step dispatched, clean up
            autoPathRef.current = null;
            setDestFlash(null);
          }
        };

        executeNextStep();
      }, [cancelAutoPath, dispatch, state.playerPos.x, state.playerPos.y]);

      // Cancel auto-path on unmount (screen change to encounter/battle)
      useEffect(() => {
        return () => cancelAutoPath();
      }, [cancelAutoPath]);

      // Cancel auto-path on map change (gate transitions)
      useEffect(() => {
        cancelAutoPath();
      }, [state.currentMap, cancelAutoPath]);

      const handleKeyDown = useCallback((e) => {
        const key = e.key.toLowerCase();
        let dx = 0, dy = 0;

        // Close examine overlay first if open
        if (state.examineText && (key === 'x' || key === 'escape' || key === 'enter' || key === 'e')) {
          cancelAutoPath();
          dispatch({ type: 'CLOSE_EXAMINE' });
          return;
        }

        if (key === 'escape') {
          cancelAutoPath();
          return; // Let App-level handler open pause menu
        }
        else if (key === 'arrowup' || key === 'w') dy = -1;
        else if (key === 'arrowdown' || key === 's') dy = 1;
        else if (key === 'arrowleft' || key === 'a') dx = -1;
        else if (key === 'arrowright' || key === 'd') dx = 1;
        else if (key === 'e' || key === 'enter') {
          cancelAutoPath();
          const tile = map[state.playerPos.y][state.playerPos.x];
          if (tile === 'B') {
            dispatch({ type: 'INTERACT_BONFIRE' });
          }
          return;
        }
        else if (key === 'x') {
          cancelAutoPath();
          dispatch({ type: 'EXAMINE_TILE' });
          return;
        }

        if (dx !== 0 || dy !== 0) {
          cancelAutoPath();
          dispatch({ type: 'MOVE_PLAYER', dx, dy });
        }
      }, [dispatch, map, state.playerPos, state.examineText, cancelAutoPath]);

      useEffect(() => {
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleKeyDown]);

      const currentTile = map[state.playerPos.y][state.playerPos.x];

      // Render tile background with area-specific styling
      const renderTileBackground = (tile, x, y) => {
        const area = state.currentMap;

        switch(tile) {
          case 'W': return <WallTile area={area} />;
          case 'P': return <PathTile area={area} />;
          case 'G': return <GrassTile area={area} />;
          case 'B': return <BonfireTile area={area} />;
          case 'X': return <GateTile area={area} />;
          case 'E': return <GateTile isKeep={true} area={area} />;
          case 'K': return <BossRoomTile area={area} />;
          case 'T': return <TorchTile area={area} />;
          case 'A': return <AshenGateTile area={area} />;
          case 'H': return <SecretDoorTile revealed={false} area={area} />;
          case 'S': return <SecretDoorTile revealed={state.secretDoorRevealed} area={area} />;
          case 'L': return <PathTile area={area} />;
          default: return <PathTile area={area} />;
        }
      };

      // Handle tile tap for movement/interaction
      const handleTileTap = (x, y, tile) => {
        // If examine overlay is open, close it
        if (state.examineText) {
          dispatch({ type: 'CLOSE_EXAMINE' });
          return;
        }

        // Block taps while bonfire/deposit/withdraw menus are open
        if (state.bonfireMenuOpen || state.depositMenuOpen || state.withdrawMenuOpen) return;

        const px = state.playerPos.x;
        const py = state.playerPos.y;
        const dx = x - px;
        const dy = y - py;
        const currentTileType = map[py][px];

        // Tap on player tile
        if (x === px && y === py) {
          cancelAutoPath();
          // If on bonfire, interact with it
          if (currentTileType === 'B') {
            dispatch({ type: 'INTERACT_BONFIRE' });
          } else {
            // Check for lore tile
            const key = `${px},${py}`;
            const hasLore = TILE_LORE[state.currentMap]?.[key];
            if (hasLore) {
              dispatch({ type: 'EXAMINE_TILE' });
            } else {
              // Open pause menu
              window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }));
            }
          }
          return;
        }

        // Check if adjacent tile (including diagonals for tap)
        const isAdjacent = Math.abs(dx) <= 1 && Math.abs(dy) <= 1;

        if (isAdjacent) {
          cancelAutoPath();
          // Move in that direction
          dispatch({ type: 'MOVE_PLAYER', dx, dy });
        } else {
          // Non-adjacent: attempt pathfinding
          if (tile === 'W' || (tile === 'S' && !state.secretDoorRevealed)) return;
          const path = findPath(map, px, py, x, y, state.secretDoorRevealed);
          if (path.length > 0) {
            startAutoPath(path);
          }
        }
      };

      return (
        <div>
          <div
            style={{ ...styles.header, cursor: isTouchDevice() ? 'pointer' : 'default' }}
            onClick={() => isTouchDevice() && window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }))}
          >
            <span style={styles.souls}>CARRIED {state.souls} | BANKED {state.bankedSouls}</span>
            <span style={{ color: GBC.textDim, display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}>
              <span style={{ fontSize: 'var(--font-xs)', color: GBC.gold }}>{state.playerName || 'Ashen One'}</span>
              <span>{mapName}</span>
            </span>
            <span style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>TEAM {state.team.length}/{GAME_CONFIG.souls.maxTeamSize}</span>
          </div>

          <div style={styles.mapContainer}>
            <div style={{
              ...styles.grid,
              gridTemplateColumns: `repeat(${map[0].length}, var(--tile-size))`
            }}>
              {map.map((row, y) =>
                row.map((tile, x) => {
                  const isPlayer = x === state.playerPos.x && y === state.playerPos.y;
                  const hasSouls = state.droppedSouls &&
                    state.droppedSouls.map === state.currentMap &&
                    state.droppedSouls.pos.x === x &&
                    state.droppedSouls.pos.y === y;

                  // Check if adjacent to player for tap highlighting
                  const px = state.playerPos.x;
                  const py = state.playerPos.y;
                  const isAdjacent = Math.abs(x - px) <= 1 && Math.abs(y - py) <= 1 && !(x === px && y === py);
                  const isWalkable = tile !== 'W';
                  const isDestFlash = destFlash && x === destFlash.x && y === destFlash.y;

                  return (
                    <div
                      key={`${x}-${y}`}
                      style={{
                        ...styles.tile,
                        cursor: isWalkable || isPlayer ? 'pointer' : 'default'
                      }}
                      onClick={() => handleTileTap(x, y, tile)}
                    >
                      {renderTileBackground(tile, x, y)}
                      {isDestFlash && (
                        <div style={{ position: 'absolute', inset: 0, zIndex: 15, animation: 'destinationFlash 0.6s ease-out forwards', pointerEvents: 'none' }} />
                      )}
                      {isPlayer && (
                        <div style={{ position: 'absolute', zIndex: 10 }}>
                          <PlayerSprite direction={state.playerDir} appearance={state.playerAppearance || 'other'} isMoving={isMoving} />
                        </div>
                      )}
                      {hasSouls && !isPlayer && (
                        <div style={{
                          position: 'absolute',
                          zIndex: 5,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}>
                          <div style={{
                            width: '28px',
                            height: '28px',
                            backgroundColor: GBC.gold,
                            border: '3px solid #744210',
                            animation: 'flicker 1s infinite',
                            boxShadow: '0 0 10px rgba(246, 224, 94, 0.5)'
                          }} />
                          <div style={{
                            fontSize: '8px',
                            color: GBC.gold,
                            fontFamily: '"Press Start 2P", monospace',
                            marginTop: '2px',
                            textShadow: '1px 1px 0 #000'
                          }}>SOULS</div>
                        </div>
                      )}
                      {ghost && ghost.map === state.currentMap &&
                        ghost.pos.x === x && ghost.pos.y === y &&
                        ghost.name && ghost.name !== state.playerName && !isPlayer && (
                        <div style={{
                          position: 'absolute',
                          zIndex: 4,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center',
                          opacity: 0.5
                        }}>
                          <div style={{ transform: 'scale(0.6)', transformOrigin: 'center', filter: 'grayscale(100%)' }}>
                            <FallbackPlayerSprite direction="down" appearance={ghost.appearance || 'other'} />
                          </div>
                          <div style={{
                            fontSize: '6px',
                            color: GBC.textDim,
                            fontFamily: '"Press Start 2P", monospace',
                            textShadow: '1px 1px 0 #000',
                            marginTop: '-4px'
                          }}>{ghost.name}...</div>
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>

          {currentTile === 'B' && !state.bonfireMenuOpen && (
            <div style={{
              textAlign: 'center',
              color: GBC.gold,
              marginBottom: 'var(--spacing-sm)',
              padding: 'var(--spacing-xs)',
              backgroundColor: GBC.bgPanel,
              border: `2px solid ${GBC.border}`,
              fontSize: 'var(--font-sm)'
            }}>
              {isTouchDevice() ? 'Tap here to rest' : 'Press E to rest at bonfire'}
            </div>
          )}

          {state.bonfireMenuOpen && (
            <div style={styles.bonfireMenu}>
              <div style={{ color: GBC.gold, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>BONFIRE</div>

              {!state.depositMenuOpen && !state.withdrawMenuOpen && (
                <React.Fragment>
                  <div
                    style={styles.bonfireOption}
                    onClick={() => { playSfx('bonfireRest'); dispatch({ type: 'REST_AT_BONFIRE' }); }}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    REST - Heal all, respawn enemies
                  </div>

                  <div
                    style={styles.bonfireOption}
                    onClick={() => dispatch({ type: 'TOGGLE_DEPOSIT_MENU' })}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    DEPOSIT - Carried  Banked
                  </div>

                  <div
                    style={styles.bonfireOption}
                    onClick={() => dispatch({ type: 'TOGGLE_WITHDRAW_MENU' })}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    WITHDRAW - Banked  Carried
                  </div>

                  {state.team.length > 1 && (
                    <div style={{ marginTop: 'var(--spacing-sm)' }}>
                      <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-xs)' }}>SWITCH ACTIVE:</div>
                      {state.team.map((creature, i) => {
                        const isActive = i === state.activeCreatureIndex;
                        const baseData = STARTERS[creature.id];
                        const { maxHp } = applyScars(creature, baseData);
                        const isAlive = creature.hp > 0;

                        return (
                          <div
                            key={i}
                            style={{
                              ...styles.bonfireOption,
                              opacity: isAlive ? 1 : 0.5,
                              cursor: isAlive && !isActive ? 'pointer' : 'default',
                              borderColor: isActive ? getTypeColor(creature.type) : GBC.border
                            }}
                            onClick={() => {
                              if (isAlive && !isActive) {
                                dispatch({ type: 'SWITCH_ACTIVE_AT_BONFIRE', index: i });
                              }
                            }}
                          >
                            <span style={{ color: getTypeColor(creature.type) }}>{getTypeIcon(creature.type)}</span>
                            {' '}{creature.nickname || creature.name} - {creature.hp}/{maxHp} HP
                            {isActive && <span style={{ color: GBC.gold, marginLeft: '6px' }}>(ACTIVE)</span>}
                            {!isAlive && <span style={{ color: GBC.red, marginLeft: '6px' }}>(FAINTED)</span>}
                            {creature.scars?.length > 0 && (
                              <span style={{ color: GBC.red, marginLeft: '6px' }}>({creature.scars.length} scars)</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}

                  <div
                    style={{ ...styles.bonfireOption, marginTop: '8px', color: GBC.textDim }}
                    onClick={() => dispatch({ type: 'CLOSE_BONFIRE_MENU' })}
                  >
                    LEAVE
                  </div>
                </React.Fragment>
              )}

              {state.depositMenuOpen && (
                <div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
                    CARRIED: {state.souls} | BANKED: {state.bankedSouls}
                  </div>
                  {(() => {
                    const available = state.souls;
                    const presets = [
                      { label: '20', amount: Math.min(20, available) },
                      { label: '50', amount: Math.min(50, available) },
                      { label: 'KEEP 20', amount: Math.max(0, available - 20) },
                      { label: 'ALL', amount: available }
                    ];
                    return presets.map(p => (
                      <div
                        key={p.label}
                        style={{
                          ...styles.bonfireOption,
                          marginTop: '4px',
                          opacity: p.amount <= 0 ? 0.4 : 1,
                          cursor: p.amount <= 0 ? 'default' : 'pointer'
                        }}
                        onClick={() => {
                          if (p.amount > 0) {
                            playSfx('bonfireRest');
                            dispatch({ type: 'DEPOSIT_SOULS', amount: p.amount });
                          }
                        }}
                        onMouseOver={e => { if (p.amount > 0) e.currentTarget.style.borderColor = GBC.gold; }}
                        onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                      >
                        {p.label}{p.amount > 0 ? ` (${p.amount})` : ''}
                      </div>
                    ));
                  })()}
                  <div
                    style={{ ...styles.bonfireOption, marginTop: '8px', color: GBC.textDim }}
                    onClick={() => dispatch({ type: 'TOGGLE_DEPOSIT_MENU' })}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    BACK
                  </div>
                </div>
              )}

              {state.withdrawMenuOpen && (
                <div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
                    CARRIED: {state.souls} | BANKED: {state.bankedSouls}
                  </div>
                  {(() => {
                    const available = state.bankedSouls;
                    const presets = [
                      { label: '20', amount: Math.min(20, available), needsConfirm: false },
                      { label: '50', amount: Math.min(50, available), needsConfirm: false },
                      { label: 'KEEP 20', amount: Math.max(0, available - 20), needsConfirm: false },
                      { label: 'ALL', amount: available, needsConfirm: true }
                    ];
                    return presets.map(p => (
                      <div
                        key={p.label}
                        style={{
                          ...styles.bonfireOption,
                          marginTop: '4px',
                          opacity: p.amount <= 0 ? 0.4 : 1,
                          cursor: p.amount <= 0 ? 'default' : 'pointer'
                        }}
                        onClick={() => {
                          if (p.amount <= 0) return;
                          if (p.needsConfirm) {
                            setConfirmDialog({
                              message: `Withdraw all ${p.amount} souls? They will be at risk.`,
                              onConfirm: () => {
                                playSfx('soulsGained');
                                dispatch({ type: 'WITHDRAW_SOULS', amount: p.amount });
                                setConfirmDialog(null);
                              },
                              onCancel: () => setConfirmDialog(null)
                            });
                          } else {
                            playSfx('soulsGained');
                            dispatch({ type: 'WITHDRAW_SOULS', amount: p.amount });
                          }
                        }}
                        onMouseOver={e => { if (p.amount > 0) e.currentTarget.style.borderColor = GBC.gold; }}
                        onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                      >
                        {p.label}{p.amount > 0 ? ` (${p.amount})` : ''}
                      </div>
                    ));
                  })()}
                  <div
                    style={{ ...styles.bonfireOption, marginTop: '8px', color: GBC.textDim }}
                    onClick={() => dispatch({ type: 'TOGGLE_WITHDRAW_MENU' })}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    BACK
                  </div>
                </div>
              )}
            </div>
          )}

          <TeamStatus team={state.team} activeIndex={state.activeCreatureIndex} />

          {/* Examine prompt when on lore tile */}
          {(() => {
            const key = `${state.playerPos.x},${state.playerPos.y}`;
            const hasLore = TILE_LORE[state.currentMap]?.[key];
            if (hasLore && !state.examineText) {
              return (
                <div style={{
                  textAlign: 'center',
                  color: GBC.gold,
                  marginBottom: 'var(--spacing-sm)',
                  padding: 'var(--spacing-xs)',
                  backgroundColor: GBC.bgPanel,
                  border: `2px solid ${GBC.border}`,
                  fontSize: 'var(--font-sm)'
                }}>
                  {isTouchDevice() ? 'Tap here to examine' : 'Press X to examine'}
                </div>
              );
            }
            return null;
          })()}

          {/* Examine overlay */}
          {state.examineText && (
            <div style={styles.examineOverlay} onClick={() => dispatch({ type: 'CLOSE_EXAMINE' })}>
              <div style={styles.examineContent} onClick={e => e.stopPropagation()}>
                <div style={styles.examineTitle}>{state.examineText.name}</div>
                {state.examineText.lines.map((line, i) => (
                  <div key={i} style={styles.examineLine}>{line || '\u00A0'}</div>
                ))}
                <div style={styles.examinePrompt}>{isTouchDevice() ? '[Tap to close]' : '[Press X to close]'}</div>
              </div>
            </div>
          )}

          {/* Keyboard hints - hidden on touch devices */}
          {!isTouchDevice() && (
            <div style={{
              padding: 'var(--spacing-xs) var(--spacing-sm)',
              backgroundColor: GBC.bgPanel,
              marginTop: 'var(--spacing-sm)',
              fontSize: 'var(--font-xs)',
              color: GBC.textDim,
              border: `2px solid ${GBC.border}`
            }}>
              WASD: Move | E: Rest | X: Examine | ESC: Menu
            </div>
          )}
        </div>
      );
    }

    function TeamStatus({ team, activeIndex }) {
      return (
        <div style={styles.teamStatus}>
          <div style={{ margin: '0 0 var(--spacing-xs)' }}>
            <span style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>TEAM</span>
          </div>
          {team.map((creature, i) => {
            const baseData = STARTERS[creature.id];
            const { maxHp, maxStamina } = applyScars(creature, baseData);
            const hpPercent = (creature.hp / (maxHp || 1)) * 100;
            const staminaPercent = (creature.stamina / (maxStamina || 1)) * 100;
            const isActive = i === activeIndex;
            const isHollowed = creature.scars && creature.scars.length >= 3;

            return (
              <div
                key={i}
                style={{
                  ...styles.creatureStatus,
                  borderColor: isActive ? getTypeColor(creature.type) : GBC.border,
                  display: 'flex',
                  alignItems: 'center'
                }}
              >
                <div style={styles.creatureSprite}>
                  <CreatureSprite type={creature.type} size={32} scarCount={creature.scars?.length || 0} isHollowed={isHollowed} />
                </div>
                <div style={{ flex: 1 }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2px' }}>
                    <span style={{ fontSize: 'var(--font-sm)' }}>
                      {creature.name}
                      {isHollowed && <span style={styles.scar}>HOLLOW</span>}
                      {creature.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND</span>}
                      {creature.burnTurns > 0 && (
                        <span style={{ ...styles.status, ...styles.burn }}>BURN</span>
                      )}
                    </span>
                    <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                      {creature.hp}/{maxHp}
                    </span>
                  </div>
                  <div style={styles.hpBar}>
                    <div style={{
                    ...styles.hpFill,
                    width: `${hpPercent}%`,
                    backgroundColor: hpPercent > 50 ? '#4a4' : hpPercent > 25 ? '#aa4' : '#a44'
                  }} />
                </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '2px' }}>
                    <span style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                      STA {creature.stamina}/{maxStamina}
                    </span>
                    {creature.scars && creature.scars.length > 0 && (
                      <span>
                        {creature.scars.slice(0, 2).map((scar, j) => (
                          <span key={j} style={styles.scar}>{scar.name.slice(0, 4)}</span>
                        ))}
                        {creature.scars.length > 2 && <span style={styles.scar}>+{creature.scars.length - 2}</span>}
                      </span>
                    )}
                  </div>
                  <div style={styles.staminaBar}>
                    <div style={{
                      ...styles.staminaFill,
                      width: `${staminaPercent}%`
                    }} />
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      );
    }

    // Damage number component for combat juice
    function DamageNumber({ damage, type, position, onComplete }) {
      useEffect(() => {
        const timer = setTimeout(onComplete, 1000);
        return () => clearTimeout(timer);
      }, [onComplete]);

      const colors = {
        normal: '#ffffff',
        effective: '#68d391',
        resisted: '#a0aec0',
        player: '#fc8181'
      };

      return (
        <div style={{
          position: 'absolute',
          top: position === 'enemy' ? '20%' : '60%',
          left: position === 'enemy' ? '70%' : '30%',
          transform: 'translateX(-50%)',
          color: colors[type] || colors.normal,
          fontSize: 'var(--font-lg)',
          fontFamily: '"Press Start 2P", monospace',
          textShadow: '2px 2px 0 #000',
          animation: 'damageNumber 1s ease-out forwards',
          pointerEvents: 'none',
          zIndex: 100
        }}>
          {damage}
        </div>
      );
    }

    function Battle({ state, dispatch }) {
      const activeCreature = state.team[state.activeCreatureIndex];
      const activeBase = STARTERS[activeCreature.id];
      const { maxHp, maxStamina, hasFlinching } = applyScars(activeCreature, activeBase);

      const enemyHpPercent = (state.enemy.hp / (state.enemyCreature.maxHp || 1)) * 100;
      const playerHpPercent = (activeCreature.hp / (maxHp || 1)) * 100;
      const prevLogLengthRef = useRef(state.battleLog.length);
      const [damageNumbers, setDamageNumbers] = useState([]);
      const [screenShake, setScreenShake] = useState(false);
      const [criticalFlash, setCriticalFlash] = useState(false);
      const damageIdRef = useRef(0);

      // Play sound effects and visual effects based on battle log changes
      useEffect(() => {
        const newLogs = state.battleLog.slice(prevLogLengthRef.current);
        prevLogLengthRef.current = state.battleLog.length;

        newLogs.forEach(log => {
          // Check for damage messages
          const damageMatch = log.match(/(\d+) damage/);
          if (damageMatch) {
            const damage = parseInt(damageMatch[1]);
            const isEffective = log.includes('super effective');
            const isResisted = log.includes('not very effective');
            const isEnemyDamage = log.includes(state.enemyCreature?.name + ' used');

            // Play sound effects
            if (isEffective) {
              playSfx('critical');
              setCriticalFlash(true);
              setTimeout(() => setCriticalFlash(false), 100);
            } else if (damage >= 15) {
              playSfx('hitHeavy');
              setScreenShake(true);
              setTimeout(() => setScreenShake(false), 200);
            } else if (damage >= 8) {
              playSfx('hitMedium');
            } else {
              playSfx('hitLight');
            }

            // Add damage number
            const dmgType = isEffective ? 'effective' : isResisted ? 'resisted' : isEnemyDamage ? 'player' : 'normal';
            const position = isEnemyDamage ? 'player' : 'enemy';
            const newDamage = {
              id: damageIdRef.current++,
              damage,
              type: dmgType,
              position
            };
            setDamageNumbers(prev => [...prev, newDamage]);
          }

          // Check for status effects
          if (log.includes('is burning')) playSfx('burn');
          if (log.includes('is poisoned')) playSfx('poison');
          if (log.includes('is chilled')) playSfx('chill');
          if (log.includes('poison damage')) playSfx('poison');
          if (log.includes('chill damage') || log.includes('frozen')) playSfx('chill');
          if (log.includes('burn damage')) playSfx('burn');

          // Check for faint
          if (log.includes('has fallen') || log.includes('defeated')) {
            playSfx('faint');
          }

          // Check for souls
          if (log.includes('Gained') && log.includes('souls')) {
            playSfx('soulsGained');
          }

          // Capture attempts
          if (log.includes('Attempting soul bind')) playSfx('bindAttempt');
          if (log.includes('joined your disaster')) playSfx('captureSuccess');
          if (log.includes('said no')) playSfx('captureFail');
        });
      }, [state.battleLog, state.enemyCreature?.name]);

      const removeDamageNumber = useCallback((id) => {
        setDamageNumbers(prev => prev.filter(d => d.id !== id));
      }, []);

      useEffect(() => {
        if (state.turnPhase === 'enemy') {
          const timer = setTimeout(() => {
            dispatch({ type: 'ENEMY_TURN' });
          }, 1000);
          return () => clearTimeout(timer);
        }
      }, [state.turnPhase, dispatch]);

      const getMoveWithPriority = (move) => {
        if (move.priority && hasFlinching) {
          return { ...move, priority: false };
        }
        return move;
      };

      // Keyboard controls for battle
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (state.turnPhase !== 'player') return;

          const moves = activeBase.moves;

          // Number keys 1-4 for moves
          if (e.key >= '1' && e.key <= '4') {
            const moveIndex = parseInt(e.key) - 1;
            if (moveIndex < moves.length) {
              const move = getMoveWithPriority(moves[moveIndex]);
              if (move.cost <= activeCreature.stamina) {
                dispatch({ type: 'SELECT_MOVE', move });
              }
            }
          }

          // B for bind/capture
          if (e.key.toLowerCase() === 'b' && !state.isBossFight) {
            dispatch({ type: 'BIND_ATTEMPT' });
          }

          // Tab to cycle through team
          if (e.key === 'Tab') {
            e.preventDefault();
            const aliveCreatures = state.team
              .map((c, i) => ({ creature: c, index: i }))
              .filter(({ creature, index }) => creature.hp > 0 && index !== state.activeCreatureIndex);
            if (aliveCreatures.length > 0) {
              dispatch({ type: 'SWITCH_CREATURE', index: aliveCreatures[0].index });
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [state.turnPhase, state.team, state.activeCreatureIndex, activeBase.moves, activeCreature.stamina, state.isBossFight, dispatch]);

      const enemyType = state.isBossFight ? (state.isHollowWardenFight ? 'hollowWarden' : 'boss') : state.enemyCreature.type;

      return (
        <div style={styles.battleContainer}>
          <div style={styles.header}>
            <span style={styles.souls}>CARRIED {state.souls}</span>
            <span style={{ color: state.isBossFight ? GBC.red : GBC.textDim, fontSize: 'var(--font-sm)' }}>
              {state.isBossFight ? 'BOSS' : 'BATTLE'}
            </span>
          </div>

          {state.arenaEffect === 'scorchedEarth' && (
            <div style={{
              textAlign: 'center',
              padding: 'var(--spacing-xs)',
              backgroundColor: '#2a1510',
              color: GBC.fire,
              marginBottom: 'var(--spacing-sm)',
              border: `2px solid ${GBC.fire}`,
              fontSize: 'var(--font-sm)',
              animation: 'flicker 0.5s infinite'
            }}>
              SCORCHED EARTH - 2 DMG/TURN
            </div>
          )}

          {/* Battle sprite arena */}
          <div
            style={styles.battleSpriteArea}
            className={`${screenShake ? 'screen-shake' : ''} ${criticalFlash ? 'critical-flash' : ''}`}
          >
            <div style={{ textAlign: 'center', position: 'relative' }}>
              <CreatureSprite type={activeCreature.type} size={48} scarCount={activeCreature.scars?.length || 0} />
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.text, marginTop: 'var(--spacing-xs)' }}>
                {activeCreature.nickname || activeCreature.name}
              </div>
            </div>
            <div style={{ fontSize: 'var(--font-xl)', color: GBC.textDim }}>VS</div>
            <div
              style={{
                textAlign: 'center',
                position: 'relative',
                cursor: state.turnPhase === 'player' ? 'pointer' : 'default',
                padding: 'var(--spacing-xs)'
              }}
              onClick={() => {
                if (state.turnPhase !== 'player') return;
                // Find first available move and use it
                const moves = activeBase.moves;
                for (let i = 0; i < moves.length; i++) {
                  const move = getMoveWithPriority(moves[i]);
                  if (move.cost <= activeCreature.stamina) {
                    playSfx('menuClick');
                    dispatch({ type: 'SELECT_MOVE', move });
                    break;
                  }
                }
              }}
              title={state.turnPhase === 'player' ? 'Tap to attack' : ''}
            >
              <CreatureSprite type={enemyType} size={state.isBossFight ? 56 : 48} isEnemy={true} bossPhase={state.bossPhase || 1} />
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.text, marginTop: 'var(--spacing-xs)' }}>{state.enemyCreature.name}</div>
              {isTouchDevice() && state.turnPhase === 'player' && (
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.gold, marginTop: '2px' }}>TAP TO ATTACK</div>
              )}
            </div>
            {/* Damage numbers */}
            {damageNumbers.map(dn => (
              <DamageNumber
                key={dn.id}
                damage={dn.damage}
                type={dn.type}
                position={dn.position}
                onComplete={() => removeDamageNumber(dn.id)}
              />
            ))}
          </div>

          {/* Enemy stats */}
          <div style={styles.battleCreature}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-xs)' }}>
              <span style={{ fontSize: 'var(--font-sm)' }}>
                {state.enemyCreature.name}
                {state.bossPhase === 2 && <span style={{ color: GBC.red, marginLeft: 'var(--spacing-xs)' }}>P2</span>}
                {state.enemy.burnTurns > 0 && <span style={{ ...styles.status, ...styles.burn }}>BRN</span>}
                {state.enemy.poisonTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a3a1a', border: '2px solid #48bb78', color: '#48bb78' }}>PSN</span>}
                {state.enemy.chillTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: '2px solid #63b3ed', color: '#63b3ed' }}>CHL</span>}
              </span>
              <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                {state.enemy.hp}/{state.enemyCreature.maxHp}
              </span>
            </div>
            <div style={styles.hpBar}>
              <div style={{
                ...styles.hpFill,
                width: `${enemyHpPercent}%`,
                backgroundColor: GBC.red
              }} />
            </div>
            <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
              STA {state.enemy.stamina}/{state.enemyCreature.maxStamina}
              {state.enemy.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND</span>}
              {state.enemy.isGuarding && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: `1px solid ${GBC.blue}`, color: GBC.blue }}>GRD</span>}
            </div>
          </div>

          {/* Battle log */}
          <div style={styles.battleAnimation}>
            {state.battleLog.slice(-2).map((log, i) => (
              <div key={i} style={{ marginBottom: '4px' }}>{log}</div>
            ))}
          </div>

          {/* Player stats */}
          <div style={styles.battleCreature}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-xs)' }}>
              <span style={{ fontSize: 'var(--font-sm)' }}>
                {activeCreature.nickname || activeCreature.name}
                {activeCreature.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND +25%</span>}
                {activeCreature.burnTurns > 0 && <span style={{ ...styles.status, ...styles.burn }}>BURN</span>}
                {activeCreature.poisonTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a3a1a', border: '2px solid #48bb78', color: '#48bb78' }}>PSN</span>}
                {activeCreature.chillTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: '2px solid #63b3ed', color: '#63b3ed' }}>CHL</span>}
                {activeCreature.isGuarding && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: `1px solid ${GBC.blue}`, color: GBC.blue }}>GRD</span>}
              </span>
              <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                {activeCreature.hp}/{maxHp}
              </span>
            </div>
            <div style={styles.hpBar} className={playerHpPercent <= 25 ? 'hp-low' : ''}>
              <div style={{
                ...styles.hpFill,
                width: `${playerHpPercent}%`,
                backgroundColor: playerHpPercent > 50 ? GBC.green : playerHpPercent > 25 ? GBC.gold : GBC.red
              }} />
            </div>
            <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
              STA {activeCreature.stamina}/{maxStamina}
              {activeCreature.scars && activeCreature.scars.length > 0 && (
                <span style={{ marginLeft: 'var(--spacing-xs)' }}>
                  {activeCreature.scars.slice(0, 2).map((scar, j) => (
                    <span key={j} style={styles.scar}>{scar.name.slice(0, 4)}</span>
                  ))}
                </span>
              )}
            </div>
            <div
              style={{
                ...styles.staminaBar,
                borderColor: activeCreature.stamina < GAME_CONFIG.combat.windedThreshold ? GBC.red : activeCreature.stamina < GAME_CONFIG.combat.windedWarningThreshold ? GBC.gold : GBC.border
              }}
              className={activeCreature.stamina < GAME_CONFIG.combat.windedThreshold ? 'stamina-warning' : ''}
            >
              <div style={{
                ...styles.staminaFill,
                width: `${(activeCreature.stamina / maxStamina) * 100}%`,
                backgroundColor: activeCreature.stamina < GAME_CONFIG.combat.windedThreshold ? GBC.red : activeCreature.stamina < GAME_CONFIG.combat.windedWarningThreshold ? GBC.gold : GBC.blue
              }} />
            </div>
          </div>

          {/* Move buttons */}
          <div style={styles.moveButtons}>
            {activeBase.moves.map((move, i) => {
              const adjustedMove = getMoveWithPriority(move);
              const canUse = adjustedMove.cost <= activeCreature.stamina && state.turnPhase === 'player';

              return (
                <button
                  key={i}
                  style={{
                    ...styles.moveButton,
                    ...(canUse ? {} : styles.moveButtonDisabled),
                    position: 'relative'
                  }}
                  disabled={!canUse}
                  onClick={() => { playSfx('menuClick'); dispatch({ type: 'SELECT_MOVE', move: adjustedMove }); }}
                >
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    left: '4px',
                    fontSize: 'var(--font-xs)',
                    color: GBC.textDim,
                    opacity: 0.6
                  }}>{i + 1}</span>
                  <div>{adjustedMove.name}</div>
                  <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
                    {adjustedMove.cost}SP
                    {adjustedMove.damage > 0 ? ` ${adjustedMove.damage}DMG` : ` ${adjustedMove.effect?.toUpperCase()}`}
                    {adjustedMove.priority && !hasFlinching && ' PRI'}
                  </div>
                </button>
              );
            })}

            {/* Bind button - only for wild creatures, not bosses */}
            {!state.isBossFight && (() => {
              const teamFull = state.team.length >= GAME_CONFIG.souls.maxTeamSize;
              const canAfford = state.souls >= GAME_CONFIG.souls.bindCost;
              const canBind = canAfford && state.turnPhase === 'player';
              const difficulty = getDifficulty(state);
              const captureChance = getCaptureChance(state.enemy.hp, state.enemy.maxHp, difficulty.captureBonus);

              return (
                <button
                  style={{
                    ...styles.bindButton,
                    ...(canBind ? {} : styles.bindButtonDisabled),
                    position: 'relative'
                  }}
                  disabled={!canBind}
                  onClick={() => dispatch({ type: 'BIND_ATTEMPT' })}
                  title={`${captureChance}% capture chance`}
                >
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    left: '4px',
                    fontSize: 'var(--font-xs)',
                    color: GBC.textDim,
                    opacity: 0.6
                  }}>B</span>
                  <div>SOUL BIND ({GAME_CONFIG.souls.bindCost} souls)</div>
                  <div style={{ fontSize: 'var(--font-xs)', marginTop: '3px', color: teamFull ? GBC.gold : 'inherit' }}>
                    {!canAfford ? `NEED ${GAME_CONFIG.souls.bindCost - state.souls} MORE SOULS` :
                     teamFull ? 'MUST RELEASE ONE' :
                     `${captureChance}% CHANCE`}
                  </div>
                </button>
              );
            })()}
          </div>

          {state.team.length > 1 && (
            <div style={{ marginTop: 'var(--spacing-sm)' }}>
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginBottom: 'var(--spacing-xs)' }}>SWITCH:</div>
              <div style={{ display: 'flex', gap: 'var(--spacing-xs)' }}>
                {state.team.map((creature, i) => {
                  if (i === state.activeCreatureIndex) return null;
                  const base = STARTERS[creature.id];
                  const stats = applyScars(creature, base);
                  return (
                    <button
                      key={i}
                      style={{
                        ...styles.moveButton,
                        flex: 1,
                        opacity: creature.hp <= 0 ? 0.5 : 1
                      }}
                      disabled={creature.hp <= 0 || state.turnPhase !== 'player'}
                      onClick={() => dispatch({ type: 'SWITCH_CREATURE', index: i })}
                    >
                      {getTypeIcon(creature.type)} {creature.nickname || creature.name} ({creature.hp}/{stats.maxHp})
                    </button>
                  );
                })}
              </div>
            </div>
          )}

          <div style={styles.log}>
            {state.battleLog.map((log, i) => (
              <div key={i} style={{ marginBottom: '2px' }}>{log}</div>
            ))}
          </div>
        </div>
      );
    }

    function Victory({ state, dispatch }) {
      const totalScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
      const survivingCreatures = state.team.filter(c => c.hp > 0).length;
      const isHollowWarden = state.hollowWardenDefeated && state.currentMap === 'hollowDeep';

      // Play victory sound on mount
      useEffect(() => {
        playSfx('victory');
      }, []);

      return (
        <div style={styles.victory}>
          {/* Boss final words */}
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              {isHollowWarden
                ? 'The Hollow Warden fractures into light and shadow. A voice echoes:'
                : 'The Obsidian Hound collapses. Varek speaks one last time:'}
            </div>
            {(isHollowWarden ? HOLLOW_WARDEN_DIALOGUE.victory : BOSS_DIALOGUE.victory).map((line, i) => (
              <div key={i} style={styles.victoryDialogue}>{line.replace('{name}', state.playerName || 'Ashen One')}</div>
            ))}
          </div>

          <div style={{
            margin: 'var(--spacing-lg) 0',
            padding: 'var(--spacing-md)',
            backgroundColor: isHollowWarden ? 'rgba(159, 122, 234, 0.1)' : 'rgba(104, 211, 145, 0.1)',
            border: `2px solid ${isHollowWarden ? GBC.dark : GBC.green}`
          }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              {isHollowWarden
                ? 'The deep falls silent. The surface awaits.'
                : 'The gate opens. Light pours through.'}
            </div>
          </div>

          <div style={styles.victoryTitle}>
            {isHollowWarden ? 'THE HOLLOW DEEP - CLEARED' : `${(state.playerName || 'ASHEN ONE').toUpperCase()} SURVIVED`}
          </div>

          <div style={{ margin: 'var(--spacing-lg) 0', textAlign: 'left', display: 'inline-block' }}>
            <p style={{ color: GBC.red, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Scars earned: {totalScars}
            </p>
            <p style={{ color: GBC.gold, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Souls banked: {state.souls + state.bankedSouls}
            </p>
            <p style={{ color: GBC.green, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Creatures bound: {state.team.length}
            </p>
            <p style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Time: {formatPlayTime(state.playTime)}
            </p>
          </div>

          <div style={styles.victorySubtitle}>
            {isHollowWarden
              ? '"You have walked through shadow and emerged."'
              : '"Scarred but not broken."'}
          </div>

          <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center', marginTop: 'var(--spacing-lg)' }}>
            <button
              style={styles.button}
              onClick={() => dispatch({ type: 'RESTART' })}
            >
              NEW GAME+
            </button>
            <button
              style={styles.button}
              onClick={() => dispatch({ type: 'SHOW_CREDITS' })}
            >
              CREDITS
            </button>
          </div>
        </div>
      );
    }

    function GameOver({ state, dispatch }) {
      const difficulty = getDifficulty(state);
      const isPermadeath = difficulty.permadeath;

      // Play death sound, record ghost/fallen, and delete save on permadeath
      useEffect(() => {
        playSfx('death');
        if (isPermadeath) {
          recordFallen(state);
          deleteSaveData();
        } else {
          recordGhost(state);
        }
      }, [isPermadeath]);

      const playerName = state.playerName || 'Ashen One';

      return (
        <div style={styles.gameOver}>
          <div style={{ fontSize: 'var(--font-lg)', color: GBC.red, marginBottom: 'var(--spacing-lg)' }}>
            {(() => {
              const deathMessages = [
                `${playerName} died. Again.`,
                "That went well.",
                "The flame remembers. Unfortunately.",
                `${playerName}'s creatures believed in them. That was their mistake.`,
                "Scars build character. You have plenty now."
              ];
              return deathMessages[Math.floor(Math.random() * deathMessages.length)];
            })()}
          </div>

          {isPermadeath && (
            <div style={{
              marginBottom: 'var(--spacing-lg)',
              padding: 'var(--spacing-md)',
              backgroundColor: 'rgba(252, 129, 129, 0.1)',
              border: `2px solid ${GBC.red}`
            }}>
              <p style={{ color: GBC.red, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-xs)' }}>PERMADEATH</p>
              <p style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>Your save has been erased.</p>
            </div>
          )}

          {state.diedToBoss && (
            <div style={{ marginBottom: 'var(--spacing-lg)' }}>
              {BOSS_DIALOGUE.playerDeath.map((line, i) => (
                <p key={i} style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', fontStyle: 'italic', marginBottom: 'var(--spacing-xs)' }}>
                  {line}
                </p>
              ))}
            </div>
          )}

          {state.droppedSouls && !isPermadeath && (
            <p style={{ color: GBC.gold, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>
              {state.droppedSouls.amount} souls dropped
            </p>
          )}

          <p style={{ color: GBC.textDim, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>
            {isPermadeath ? 'Broken beyond repair.' : 'Scarred but not broken.'}
          </p>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: isPermadeath ? 'RESTART' : 'RESPAWN' })}
          >
            {isPermadeath ? 'NEW GAME' : 'RETURN'}
          </button>
        </div>
      );
    }

    function Prologue({ dispatch, state }) {
      const getAppearanceLine = (appearance) => {
        switch(appearance) {
          case 'male':
          case 'female':
            return "A warrior's path lies ahead.";
          default:
            return 'Your path is your own to forge.';
        }
      };

      const prologueLines = [
        { text: 'The bonfire wars ended long ago.', highlight: false },
        { text: '', highlight: false },
        { text: 'Binders and their companions fell, one by one.', highlight: false },
        { text: '', highlight: false },
        { text: 'The creatures that survived... changed.', highlight: false },
        { text: '', highlight: false },
        { text: 'Now they wander the ashen paths, feral and scarred.', highlight: false },
        { text: '', highlight: false },
        { text: 'You are not the first to wake at this flame.', highlight: true },
        { text: '', highlight: false },
        { text: 'You will not be the last.', highlight: false },
        { text: '', highlight: false },
        { text: 'But perhaps you will be the one who endures.', highlight: true },
        { text: '', highlight: false },
        { text: getAppearanceLine(state?.playerAppearance), highlight: true }
      ];

      return (
        <div style={styles.prologue}>
          <div style={{ marginBottom: 'var(--spacing-xl)' }}>
            {prologueLines.map((line, i) => (
              <div
                key={i}
                style={line.highlight ? styles.prologueHighlight : styles.prologueLine}
              >
                {line.text || '\u00A0'}
              </div>
            ))}
          </div>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: 'CONTINUE_FROM_PROLOGUE' })}
          >
            CONTINUE
          </button>
        </div>
      );
    }

    function Credits({ dispatch }) {
      return (
        <div style={styles.credits}>
          <div style={styles.creditsTitle}>SCARS OF ASH</div>

          <div style={{ marginBottom: 'var(--spacing-xl)' }}>
            <div style={{ color: GBC.gold, fontSize: 'var(--font-sm)', fontStyle: 'italic' }}>
              The flame remembers.
            </div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Created by</div>
            <div style={styles.creditsValue}>BBAD Games</div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Built with</div>
            <div style={styles.creditsValue}>Claude Code</div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Music</div>
            <div style={styles.creditsValue}>Procedural chiptune via Tone.js</div>
          </div>

          <div style={styles.creditsQuote}>
            "The bonfire wars are over.<br/>
            But the flames still burn.<br/>
            And someone must carry them forward."
          </div>

          <div style={{ marginTop: 'var(--spacing-lg)', marginBottom: 'var(--spacing-lg)' }}>
            <div style={{ color: GBC.text, fontSize: 'var(--font-sm)' }}>
              Thank you for playing.
            </div>
          </div>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: 'RETURN_TO_TITLE' })}
          >
            RETURN TO TITLE
          </button>
        </div>
      );
    }

    function ReleaseScreen({ state, dispatch }) {
      const [selectedIndex, setSelectedIndex] = useState(null);
      const [confirmOpen, setConfirmOpen] = useState(false);
      const pendingCreature = state.pendingCapture;

      const handleSelect = (index) => {
        playSfx('menuClick');
        setSelectedIndex(index);
        setConfirmOpen(true);
      };

      const handleConfirmRelease = () => {
        playSfx('menuClick');
        dispatch({ type: 'RELEASE_FOR_CAPTURE', releaseIndex: selectedIndex });
      };

      const handleCancel = () => {
        playSfx('menuClick');
        setConfirmOpen(false);
        setSelectedIndex(null);
      };

      const handleEscape = () => {
        playSfx('menuClick');
        dispatch({ type: 'CANCEL_CAPTURE' });
      };

      if (!pendingCreature) return null;

      const selectedCreature = selectedIndex !== null ? state.team[selectedIndex] : null;

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          display: 'flex',
          flexDirection: 'column',
          padding: 'var(--spacing-md)'
        }}>
          {/* Header */}
          <div style={{ textAlign: 'center', marginBottom: 'var(--spacing-md)' }}>
            <div style={{ color: GBC.gold, fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-sm)' }}>
              TEAM FULL
            </div>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>
              Release one to make room for {pendingCreature.name}
            </div>
          </div>

          {/* Pending creature preview */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 'var(--spacing-md)',
            marginBottom: 'var(--spacing-md)',
            padding: 'var(--spacing-sm)',
            backgroundColor: 'rgba(245, 203, 92, 0.1)',
            border: `2px solid ${GBC.gold}`
          }}>
            <CreatureSprite type={pendingCreature.type} size={32} scarCount={pendingCreature.scars?.length || 0} />
            <div>
              <div style={{ color: GBC.gold, fontSize: 'var(--font-sm)' }}>
                {getTypeIcon(pendingCreature.type)} {pendingCreature.name}
              </div>
              <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>
                HP: {pendingCreature.hp}/{pendingCreature.maxHp} | Scars: {pendingCreature.scars?.length || 0}
              </div>
            </div>
          </div>

          {/* Confirmation dialog */}
          {confirmOpen && selectedCreature && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0, 0, 0, 0.85)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 100,
              padding: 'var(--spacing-md)'
            }}>
              <div style={{
                backgroundColor: GBC.bg,
                border: `3px solid ${GBC.red}`,
                padding: 'var(--spacing-lg)',
                maxWidth: '350px',
                textAlign: 'center'
              }}>
                <div style={{ marginBottom: 'var(--spacing-md)' }}>
                  <CreatureSprite type={selectedCreature.type} size={48} scarCount={selectedCreature.scars?.length || 0} />
                </div>
                <div style={{ color: GBC.red, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-sm)' }}>
                  Release {selectedCreature.nickname || selectedCreature.name} forever?
                </div>
                <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-lg)' }}>
                  They will not return.
                </div>
                <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center' }}>
                  <button
                    style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-lg)' }}
                    onClick={handleCancel}
                  >
                    BACK
                  </button>
                  <button
                    style={{
                      ...styles.button,
                      padding: 'var(--spacing-sm) var(--spacing-lg)',
                      borderColor: GBC.red,
                      color: GBC.red
                    }}
                    onClick={handleConfirmRelease}
                  >
                    RELEASE
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Team list */}
          <div style={{ flex: 1, overflow: 'auto' }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              SELECT CREATURE TO RELEASE:
            </div>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 'var(--spacing-sm)' }}>
              {state.team.map((creature, i) => {
                const base = STARTERS[creature.id];
                const difficulty = getDifficulty(state);
                const stats = applyScars(creature, base, difficulty.hollowedThreshold);
                const isHollowed = (creature.scars?.length || 0) >= difficulty.hollowedThreshold;

                return (
                  <button
                    key={i}
                    style={{
                      ...styles.button,
                      display: 'flex',
                      alignItems: 'center',
                      gap: 'var(--spacing-sm)',
                      padding: 'var(--spacing-sm)',
                      textAlign: 'left',
                      minHeight: '60px'
                    }}
                    onClick={() => handleSelect(i)}
                  >
                    <CreatureSprite type={creature.type} size={32} scarCount={creature.scars?.length || 0} isHollowed={isHollowed} />
                    <div style={{ flex: 1 }}>
                      <div style={{ color: isHollowed ? GBC.textDim : GBC.text, fontSize: 'var(--font-sm)' }}>
                        {getTypeIcon(creature.type)} {creature.nickname || creature.name}
                        {isHollowed && <span style={{ color: GBC.textDim }}> (Hollowed)</span>}
                      </div>
                      <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginTop: '2px' }}>
                        HP: {creature.hp}/{stats.maxHp} | SP: {creature.stamina}/{stats.maxStamina} | Scars: {creature.scars?.length || 0}
                      </div>
                      {creature.scars?.length > 0 && (
                        <div style={{ color: GBC.red, fontSize: 'var(--font-xs)', marginTop: '2px' }}>
                          {creature.scars.map(s => s.name).join(', ')}
                        </div>
                      )}
                    </div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Cancel option */}
          <div style={{ marginTop: 'var(--spacing-md)', textAlign: 'center' }}>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-lg)',
                borderColor: GBC.textDim,
                color: GBC.textDim
              }}
              onClick={handleEscape}
            >
              LET IT ESCAPE
            </button>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginTop: 'var(--spacing-xs)' }}>
              (Souls already spent)
            </div>
          </div>
        </div>
      );
    }

    function NicknameScreen({ creature, dispatch }) {
      const [nickname, setNickname] = useState('');
      const inputRef = useRef(null);

      useEffect(() => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      }, []);

      const handleSubmit = (e) => {
        e.preventDefault();
        playSfx('captureSuccess');
        dispatch({ type: 'SET_NICKNAME', nickname: nickname.trim() || null });
      };

      const handleSkip = () => {
        playSfx('menuClick');
        dispatch({ type: 'SET_NICKNAME', nickname: null });
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 60vh, 600px)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <CreatureSprite type={creature.type} size={64} scarCount={creature.scars?.length || 0} />
          </div>

          <div style={{ color: GBC.gold, fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-sm)' }}>
            {creature.name} joined your disaster.
          </div>

          <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
            Give your new companion a name?
          </div>

          <form onSubmit={handleSubmit} style={{ width: '100%', maxWidth: '300px' }}>
            <input
              ref={inputRef}
              type="text"
              value={nickname}
              onChange={(e) => setNickname(e.target.value.slice(0, 12))}
              placeholder={creature.name}
              maxLength={12}
              style={{
                width: '100%',
                padding: 'var(--spacing-md)',
                backgroundColor: GBC.bgLight,
                border: `3px solid ${GBC.border}`,
                color: GBC.text,
                fontFamily: '"Press Start 2P", monospace',
                fontSize: 'var(--font-sm)',
                textAlign: 'center',
                marginBottom: 'var(--spacing-md)'
              }}
            />

            <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center' }}>
              <button
                type="button"
                style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-lg)' }}
                onClick={handleSkip}
              >
                SKIP
              </button>
              <button
                type="submit"
                style={{
                  ...styles.button,
                  padding: 'var(--spacing-sm) var(--spacing-lg)',
                  borderColor: GBC.gold,
                  color: GBC.gold
                }}
              >
                CONFIRM
              </button>
            </div>
          </form>
        </div>
      );
    }

    function EncounterPreview({ encounter, dispatch }) {
      if (!encounter) return null;
      const { wildData } = encounter;

      const handleFight = () => {
        playSfx('menuClick');
        dispatch({ type: 'CONFIRM_ENCOUNTER' });
      };

      const handleFlee = () => {
        playSfx('menuClick');
        dispatch({ type: 'FLEE_ENCOUNTER' });
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(300px, 50vh, 400px)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
            Something stirs in the grass...
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <div style={{
              width: '80px',
              height: '80px',
              backgroundColor: GBC.bgLight,
              border: `3px solid ${getTypeColor(wildData.type)}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 'var(--font-2xl)'
            }}>
              {getTypeIcon(wildData.type)}
            </div>
          </div>

          <div style={{ color: getTypeColor(wildData.type), fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-xs)' }}>
            {wildData.type.toUpperCase()} TYPE
          </div>

          <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-lg)' }}>
            Wild creature detected
          </div>

          <div style={{ display: 'flex', gap: 'var(--spacing-md)' }}>
            <button
              style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-xl)' }}
              onClick={handleFlee}
            >
              FLEE
            </button>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)',
                borderColor: GBC.gold,
                color: GBC.gold
              }}
              onClick={handleFight}
            >
              FIGHT
            </button>
          </div>
        </div>
      );
    }

    function StatsScreen({ onClose }) {
      const stats = loadStats();
      const allCreatures = ['cindrath', 'marshveil', 'thornwick', 'umbravine', 'solrath'];

      const achievements = [
        {
          id: 'unscarred',
          name: 'Unscarred',
          desc: 'Beat the game with 0 scars',
          unlocked: Object.values(stats.lowestScars).some(s => s === 0)
        },
        {
          id: 'collector',
          name: 'Collector',
          desc: 'Capture all 5 creature types',
          unlocked: allCreatures.every(c => stats.creaturesCollected.includes(c))
        },
        {
          id: 'trueHollow',
          name: 'True Hollow',
          desc: 'Defeat the Hollow Warden on Broken',
          unlocked: stats.hollowWardenDefeated && stats.completedRuns.broken > 0
        },
        {
          id: 'speedrunner',
          name: 'Speedrunner',
          desc: 'Clear in under 20 minutes',
          unlocked: Object.values(stats.fastestClear).some(t => t !== null && t < 20 * 60 * 1000)
        }
      ];

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          overflowY: 'auto'
        }}>
          <h1 style={{ color: GBC.gold, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-xl)' }}>
            STATISTICS
          </h1>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              OVERALL
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Runs: {stats.totalRuns}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Deaths: {stats.totalDeaths}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Scars: {stats.totalScarsEarned}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Creatures Captured: {stats.totalCreaturesCaptured}
            </div>
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              CLEARS BY DIFFICULTY
            </div>
            {Object.entries(DIFFICULTIES).map(([id, diff]) => (
              <div key={id} style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
                {diff.icon} {diff.name}: {stats.completedRuns[id] || 0}
                {stats.fastestClear[id] && (
                  <span style={{ color: GBC.textDim }}> (Best: {formatPlayTime(stats.fastestClear[id])})</span>
                )}
              </div>
            ))}
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              ACHIEVEMENTS
            </div>
            {achievements.map(ach => (
              <div
                key={ach.id}
                style={{
                  color: ach.unlocked ? GBC.gold : GBC.textDim,
                  fontSize: 'var(--font-xs)',
                  marginBottom: '4px',
                  opacity: ach.unlocked ? 1 : 0.6
                }}
              >
                {ach.unlocked ? '' : ''} {ach.name}
                <span style={{ color: GBC.textDim, marginLeft: '8px' }}>
                  - {ach.desc}
                </span>
              </div>
            ))}
          </div>

          <button
            style={styles.button}
            onClick={onClose}
          >
            BACK
          </button>
        </div>
      );
    }

    function HallOfFallen({ onClose }) {
      const fallen = loadFallen();
      const mapNames = {
        ashenPath: 'Ashen Path',
        fallenKeep: 'Fallen Keep',
        hollowDeep: 'The Hollow Deep',
        labyrinth: 'The Labyrinth'
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          overflowY: 'auto'
        }}>
          <h1 style={{ color: GBC.red, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-xl)' }}>
            HALL OF THE FALLEN
          </h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', fontStyle: 'italic', marginBottom: 'var(--spacing-lg)' }}>
            The flame remembers those who burned brightest.
          </div>

          {fallen.length === 0 ? (
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
              No souls have fallen on the Broken path... yet.
            </div>
          ) : (
            <div style={{ width: '100%', maxWidth: '400px' }}>
              {fallen.map(entry => (
                <div key={entry.id} style={{
                  backgroundColor: GBC.bgPanel,
                  border: `2px solid ${GBC.border}`,
                  padding: 'var(--spacing-sm)',
                  marginBottom: 'var(--spacing-sm)',
                  textAlign: 'left'
                }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 'var(--spacing-sm)', marginBottom: 'var(--spacing-xs)' }}>
                    <div style={{ width: '24px', height: '24px', overflow: 'hidden', flexShrink: 0 }}>
                      <div style={{ transform: 'scale(0.5)', transformOrigin: 'top left' }}>
                        <PlayerSprite direction="down" appearance={entry.playerAppearance || 'other'} />
                      </div>
                    </div>
                    <div style={{ color: GBC.red, fontSize: 'var(--font-sm)' }}>{entry.playerName}</div>
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: '2px' }}>
                    Fell at: {mapNames[entry.finalMap] || entry.finalMap}
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: '2px' }}>
                    Time: {formatPlayTime(entry.playTime || 0)} | Scars: {entry.totalScars}
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>
                    Team: {(entry.team || []).map(c => c.name).join(', ') || 'Unknown'}
                  </div>
                </div>
              ))}
            </div>
          )}

          <button
            style={styles.button}
            onClick={onClose}
          >
            BACK
          </button>
        </div>
      );
    }

    function MuteButton({ muted, onToggle }) {
      return (
        <button
          style={styles.muteButton}
          onClick={onToggle}
          title={muted ? 'Unmute' : 'Mute'}
        >
          {muted ? '' : ''}
        </button>
      );
    }

    function HelpButton({ onClick }) {
      return (
        <button
          style={styles.helpButton}
          onClick={onClick}
          title="How to Play"
        >
          ?
        </button>
      );
    }

    function GearButton({ onClick }) {
      return (
        <button
          style={styles.gearButton}
          onClick={onClick}
          title="Menu (ESC)"
        >
          
        </button>
      );
    }

    function ConfirmDialog({ message, onConfirm, onCancel, confirmText = 'YES', cancelText = 'NO', danger = true }) {
      return (
        <div style={styles.confirmOverlay} onClick={onCancel}>
          <div style={styles.confirmDialog} onClick={e => e.stopPropagation()}>
            <div style={styles.confirmText}>{message}</div>
            <div style={styles.confirmButtons}>
              <button
                style={styles.confirmButton}
                onClick={onCancel}
              >
                {cancelText}
              </button>
              <button
                style={{
                  ...styles.confirmButton,
                  ...(danger ? styles.confirmButtonDanger : {})
                }}
                onClick={onConfirm}
              >
                {confirmText}
              </button>
            </div>
          </div>
        </div>
      );
    }

    function SaveSlotDisplay({ saveData }) {
      if (!saveData) return null;

      const totalScars = saveData.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
      const leadCreature = saveData.team[saveData.activeCreatureIndex] || saveData.team[0];
      const mapName = saveData.currentMap === 'ashenPath' ? 'Ashen Path' : saveData.currentMap === 'hollowDeep' ? 'The Hollow Deep' : saveData.currentMap === 'labyrinth' ? 'The Labyrinth' : 'Fallen Keep';
      const diff = DIFFICULTIES[saveData.difficulty] || DIFFICULTIES.scarred;

      const playerName = saveData.playerName || 'Ashen One';

      return (
        <div style={styles.saveSlot}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-sm)' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 'var(--spacing-sm)' }}>
              <div style={{ width: '16px', height: '16px', overflow: 'hidden' }}>
                <div style={{ transform: 'scale(0.333)', transformOrigin: 'top left' }}>
                  <PlayerSprite direction="down" appearance={saveData.playerAppearance || 'other'} />
                </div>
              </div>
              <div style={styles.saveSlotTitle}>{playerName.toUpperCase()}'S JOURNEY</div>
            </div>
            <div style={{ fontSize: 'var(--font-base)' }}>
              {diff.icon} <span style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>{diff.name}</span>
            </div>
          </div>
          <div style={styles.saveSlotStat}>
            Lead: {leadCreature?.name || 'Unknown'} ({saveData.team.length} creature{saveData.team.length > 1 ? 's' : ''})
          </div>
          <div style={styles.saveSlotStat}>
            Location: {mapName}
          </div>
          <div style={styles.saveSlotStat}>
            Souls banked: {saveData.bankedSouls}
          </div>
          <div style={styles.saveSlotStat}>
            Scars: {totalScars}
          </div>
          <div style={styles.saveSlotStat}>
            Time played: {formatPlayTime(saveData.playTime || 0)}
          </div>
          {saveData.bossDefeated && (
            <div style={{ ...styles.saveSlotStat, color: GBC.gold }}>
              Boss defeated
            </div>
          )}
        </div>
      );
    }

    function PauseMenu({ onResume, onSave, onLoad, onNewGame, onHelp, hasSave, state }) {
      return (
        <div style={styles.pauseOverlay}>
          <div style={styles.pauseMenu}>
            <div style={styles.pauseTitle}>PAUSED</div>

            {state && (
              <div style={{
                marginBottom: 'var(--spacing-md)',
                padding: 'var(--spacing-sm)',
                backgroundColor: GBC.bgPanel,
                border: `2px solid ${GBC.border}`,
                display: 'flex',
                alignItems: 'center',
                gap: 'var(--spacing-sm)'
              }}>
                <div style={{ width: '24px', height: '24px', overflow: 'hidden', flexShrink: 0 }}>
                  <div style={{ transform: 'scale(0.5)', transformOrigin: 'top left' }}>
                    <PlayerSprite direction="down" appearance={state.playerAppearance || 'other'} />
                  </div>
                </div>
                <div style={{ textAlign: 'left' }}>
                  <div style={{ color: GBC.text, fontSize: 'var(--font-xs)' }}>
                    {state.playerName || 'Ashen One'}
                    {state.activeTitle && (() => {
                      const titleData = TITLES.find(t => t.id === state.activeTitle);
                      return titleData ? `, ${titleData.name}` : '';
                    })()}
                  </div>
                  <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)' }}>
                    {state.souls}/{state.bankedSouls} souls
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>
                    {state.team.length} creature{state.team.length !== 1 ? 's' : ''} | {state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0)} scar{state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0) !== 1 ? 's' : ''}
                  </div>
                </div>
              </div>
            )}

            <div
              style={styles.pauseOption}
              onClick={onResume}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              RESUME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onSave}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              SAVE GAME
            </div>

            <div
              style={{
                ...styles.pauseOption,
                ...(hasSave ? {} : styles.pauseOptionDisabled)
              }}
              onClick={hasSave ? onLoad : undefined}
              onMouseOver={e => hasSave && (e.currentTarget.style.borderColor = GBC.gold)}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              LOAD GAME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onNewGame}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.red}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              NEW GAME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onHelp}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              HELP
            </div>
          </div>
        </div>
      );
    }

    function LoadScreen({ saveData, onContinue, onNewGame }) {
      return (
        <div style={styles.loadScreen}>
          <div style={styles.loadTitle}>Continue your journey?</div>

          <SaveSlotDisplay saveData={saveData} />

          <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', marginTop: '20px' }}>
            <button
              style={styles.button}
              onClick={onNewGame}
            >
              NEW GAME
            </button>
            <button
              style={{ ...styles.button, borderColor: GBC.gold, color: GBC.gold }}
              onClick={onContinue}
            >
              CONTINUE
            </button>
          </div>
        </div>
      );
    }

    function SaveNotification({ message, onDismiss }) {
      useEffect(() => {
        const timer = setTimeout(onDismiss, 2500);
        return () => clearTimeout(timer);
      }, [onDismiss]);

      return (
        <div style={styles.saveNotification}>
          {message}
        </div>
      );
    }

    function HelpOverlay({ onClose }) {
      return (
        <div style={styles.helpOverlay} onClick={onClose}>
          <div style={styles.helpContent} onClick={e => e.stopPropagation()}>
            <div style={styles.helpTitle}>HOW TO SURVIVE</div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>CONTROLS</div>
              <div style={styles.helpText}>
                WASD/Arrows - Move<br/>
                E - Rest at bonfire<br/>
                X - Examine surroundings<br/>
                ESC - Pause menu<br/>
                Click - Select moves
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>STAMINA (Battle Only)</div>
              <div style={styles.helpText}>
                Every battle move costs stamina.<br/>
                End turn below 5 = "Winded" (take +25% damage)<br/>
                REST move in battle: Recover 12 SP (skips attack)<br/>
                Bonfire rest: Fully restores stamina
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>SOULS</div>
              <div style={styles.helpText}>
                Earn from victories. Drop ALL on death.<br/>
                Die again before reclaiming = gone forever.<br/>
                Bank at bonfires for safety.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>SCARS</div>
              <div style={styles.helpText}>
                Creatures gain permanent scars when they faint.<br/>
                Three scars = Hollowed (75% stats)
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>BONFIRE</div>
              <div style={styles.helpText}>
                Heals team. Banks souls. BUT respawns all enemies.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>CAPTURE</div>
              <div style={styles.helpText}>
                SOUL BIND costs 20 souls. Lower HP = better odds.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>TYPE MATCHUPS</div>
              <div style={styles.helpText}>
                <span style={{ color: GBC.fire }}>Fire</span> &gt; <span style={{ color: GBC.grass }}>Grass</span> &gt; <span style={{ color: GBC.water }}>Water</span> &gt; <span style={{ color: GBC.fire }}>Fire</span>
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>GOAL</div>
              <div style={styles.helpText}>
                Defeat Keeper Varek in the Fallen Keep.
              </div>
            </div>

            <div style={styles.helpQuote}>"Scarred but not broken."</div>

            <button style={styles.helpClose} onClick={onClose}>
              CLOSE
            </button>
          </div>
        </div>
      );
    }

    // Tap to Start splash screen
    function TapToStart({ onStart }) {
      return (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: GBC.bg,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            fontFamily: '"Press Start 2P", monospace',
            cursor: 'pointer',
            zIndex: 9999,
            padding: 'var(--spacing-lg)',
          }}
          onClick={onStart}
          onTouchStart={onStart}
        >
          <img
            src="assets/logo.png"
            alt="Scars of Ash"
            style={{
              maxWidth: '80%',
              maxHeight: '40vh',
              width: 'auto',
              height: 'auto',
              imageRendering: 'pixelated',
              marginBottom: 'var(--spacing-lg)',
            }}
          />
          <div style={{
            fontSize: 'var(--font-sm)',
            color: GBC.gold,
            marginBottom: 'var(--spacing-md)',
            textAlign: 'center',
            animation: 'flicker 2s infinite',
            textShadow: '1px 1px 0 #744210'
          }}>
            WARNING: THIS GAME MAY BREAK YOU
          </div>
          <div style={{
            fontSize: 'var(--font-xs)',
            color: GBC.textDim,
            marginBottom: 'var(--spacing-xl)'
          }}>
            The flame remembers.
          </div>
          <div style={{
            fontSize: 'var(--font-base)',
            color: GBC.text,
            animation: 'flicker 1.5s infinite'
          }}>
            {isTouchDevice() ? 'TAP TO START' : 'CLICK TO START'}
          </div>
        </div>
      );
    }


    // ============= DEV DASHBOARD =============

const ConfigSlider = ({ label, value, min, max, step, onChange, color }) => {
  const c = color || '#f6e05e';
  return (
    <div style={{ marginBottom: 10 }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 11, fontFamily: "'IBM Plex Mono', monospace" }}>
        <span style={{ color: '#a0aec0' }}>{label}</span>
        <span style={{ color: c, fontWeight: 'bold' }}>{typeof value === 'number' ? (Number.isInteger(value) ? value : value.toFixed(2)) : value}</span>
      </div>
      <input
        type="range"
        min={min}
        max={max}
        step={step || 1}
        value={value}
        onChange={e => onChange(parseFloat(e.target.value))}
        style={{
          width: '100%',
          height: 6,
          marginTop: 4,
          appearance: 'none',
          WebkitAppearance: 'none',
          background: `linear-gradient(to right, ${c}88 0%, ${c}88 ${((value - min) / (max - min)) * 100}%, #333 ${((value - min) / (max - min)) * 100}%, #333 100%)`,
          borderRadius: 3,
          outline: 'none',
          cursor: 'pointer',
          accentColor: c
        }}
      />
    </div>
  );
};

const DevDashboard = ({ onClose, onModified }) => {
  const [activeTab, setActiveTab] = useState('COMBAT');
  const [, forceUpdate] = useState(0);
  const [simAttacker, setSimAttacker] = useState('cindrath');
  const [simMove, setSimMove] = useState(0);
  const [simDefender, setSimDefender] = useState('cindrath');
  const [simDifficulty, setSimDifficulty] = useState('scarred');
  const [simWinded, setSimWinded] = useState(false);
  const [simGuarding, setSimGuarding] = useState(false);
  const [simScarred, setSimScarred] = useState(false);
  const [importText, setImportText] = useState('');
  const [importMsg, setImportMsg] = useState('');
  const [expandedBoss, setExpandedBoss] = useState(null);
  const [expandedCreature, setExpandedCreature] = useState(null);
  const snapshots = useRef(null);

  // Store original snapshots on first render
  useEffect(() => {
    if (!snapshots.current) {
      snapshots.current = {
        STARTERS: JSON.parse(JSON.stringify(STARTERS)),
        WILD_CREATURES: JSON.parse(JSON.stringify(WILD_CREATURES)),
        BOSS: JSON.parse(JSON.stringify(BOSS)),
        TYPE_CHART: JSON.parse(JSON.stringify(TYPE_CHART)),
        SCAR_TYPES: JSON.parse(JSON.stringify(SCAR_TYPES)),
        DIFFICULTIES: JSON.parse(JSON.stringify(DIFFICULTIES)),
        GAME_CONFIG: JSON.parse(JSON.stringify(window.GAME_CONFIG))
      };
      console.log('Dev Dashboard active. Live tuning enabled.');
    }
  }, []);

  const rerender = () => forceUpdate(n => n + 1);

  const updateConfig = (path, value) => {
    const keys = path.split('.');
    let obj = window.GAME_CONFIG;
    for (let i = 0; i < keys.length - 1; i++) obj = obj[keys[i]];
    obj[keys[keys.length - 1]] = value;
    onModified(true);
    rerender();
  };

  const getConfig = (path) => {
    const keys = path.split('.');
    let obj = window.GAME_CONFIG;
    for (const k of keys) obj = obj[k];
    return obj;
  };

  const resetAll = () => {
    if (!snapshots.current) return;
    window.GAME_CONFIG = JSON.parse(JSON.stringify(snapshots.current.GAME_CONFIG));
    window.GAME_CONFIG_DEFAULTS = JSON.parse(JSON.stringify(snapshots.current.GAME_CONFIG));
    // Reset game objects
    Object.keys(snapshots.current.STARTERS).forEach(k => { Object.assign(STARTERS[k], JSON.parse(JSON.stringify(snapshots.current.STARTERS[k]))); });
    Object.keys(snapshots.current.WILD_CREATURES).forEach(k => { Object.assign(WILD_CREATURES[k], JSON.parse(JSON.stringify(snapshots.current.WILD_CREATURES[k]))); });
    Object.keys(snapshots.current.BOSS).forEach(k => { Object.assign(BOSS[k], JSON.parse(JSON.stringify(snapshots.current.BOSS[k]))); });
    Object.keys(snapshots.current.TYPE_CHART).forEach(k => { TYPE_CHART[k] = JSON.parse(JSON.stringify(snapshots.current.TYPE_CHART[k])); });
    SCAR_TYPES.length = 0;
    snapshots.current.SCAR_TYPES.forEach(s => SCAR_TYPES.push(JSON.parse(JSON.stringify(s))));
    Object.keys(snapshots.current.DIFFICULTIES).forEach(k => { Object.assign(DIFFICULTIES[k], JSON.parse(JSON.stringify(snapshots.current.DIFFICULTIES[k]))); });
    onModified(false);
    rerender();
  };

  const resetTab = () => {
    if (!snapshots.current) return;
    const cfg = snapshots.current.GAME_CONFIG;
    switch (activeTab) {
      case 'COMBAT':
        window.GAME_CONFIG.combat = JSON.parse(JSON.stringify(cfg.combat));
        break;
      case 'STATUS':
        window.GAME_CONFIG.statusFx = JSON.parse(JSON.stringify(cfg.statusFx));
        break;
      case 'SCARS':
        window.GAME_CONFIG.scars = JSON.parse(JSON.stringify(cfg.scars));
        SCAR_TYPES.length = 0;
        snapshots.current.SCAR_TYPES.forEach(s => SCAR_TYPES.push(JSON.parse(JSON.stringify(s))));
        break;
      case 'DIFFICULTY':
        Object.keys(snapshots.current.DIFFICULTIES).forEach(k => { Object.assign(DIFFICULTIES[k], JSON.parse(JSON.stringify(snapshots.current.DIFFICULTIES[k]))); });
        break;
      case 'BOSSES':
        Object.keys(snapshots.current.BOSS).forEach(k => { Object.assign(BOSS[k], JSON.parse(JSON.stringify(snapshots.current.BOSS[k]))); });
        window.GAME_CONFIG.bosses = JSON.parse(JSON.stringify(cfg.bosses));
        break;
      case 'SOULS':
        window.GAME_CONFIG.souls = JSON.parse(JSON.stringify(cfg.souls));
        break;
      case 'ENCOUNTERS':
        window.GAME_CONFIG.wildEncounters = JSON.parse(JSON.stringify(cfg.wildEncounters));
        break;
      case 'CREATURES':
        Object.keys(snapshots.current.STARTERS).forEach(k => { Object.assign(STARTERS[k], JSON.parse(JSON.stringify(snapshots.current.STARTERS[k]))); });
        Object.keys(snapshots.current.WILD_CREATURES).forEach(k => { Object.assign(WILD_CREATURES[k], JSON.parse(JSON.stringify(snapshots.current.WILD_CREATURES[k]))); });
        break;
      case 'TYPE CHART':
        Object.keys(snapshots.current.TYPE_CHART).forEach(k => { TYPE_CHART[k] = JSON.parse(JSON.stringify(snapshots.current.TYPE_CHART[k])); });
        break;
    }
    onModified(true);
    rerender();
  };

  const doExport = () => {
    const data = {
      GAME_CONFIG: window.GAME_CONFIG,
      STARTERS, WILD_CREATURES, BOSS, TYPE_CHART, SCAR_TYPES, DIFFICULTIES
    };
    navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => {
      setImportMsg('Copied to clipboard!');
      setTimeout(() => setImportMsg(''), 2000);
    });
  };

  const doImport = () => {
    try {
      const data = JSON.parse(importText);
      if (data.GAME_CONFIG) {
        window.GAME_CONFIG = data.GAME_CONFIG;
        window.GAME_CONFIG_DEFAULTS = JSON.parse(JSON.stringify(data.GAME_CONFIG));
      }
      if (data.STARTERS) Object.keys(data.STARTERS).forEach(k => { if (STARTERS[k]) Object.assign(STARTERS[k], data.STARTERS[k]); });
      if (data.WILD_CREATURES) Object.keys(data.WILD_CREATURES).forEach(k => { if (WILD_CREATURES[k]) Object.assign(WILD_CREATURES[k], data.WILD_CREATURES[k]); });
      if (data.BOSS) Object.keys(data.BOSS).forEach(k => { if (BOSS[k]) Object.assign(BOSS[k], data.BOSS[k]); });
      if (data.TYPE_CHART) Object.keys(data.TYPE_CHART).forEach(k => { TYPE_CHART[k] = data.TYPE_CHART[k]; });
      if (data.SCAR_TYPES) { SCAR_TYPES.length = 0; data.SCAR_TYPES.forEach(s => SCAR_TYPES.push(s)); }
      if (data.DIFFICULTIES) Object.keys(data.DIFFICULTIES).forEach(k => { if (DIFFICULTIES[k]) Object.assign(DIFFICULTIES[k], data.DIFFICULTIES[k]); });
      onModified(true);
      setImportMsg('Import successful!');
      setImportText('');
      rerender();
    } catch (e) {
      setImportMsg('Import failed: ' + e.message);
    }
    setTimeout(() => setImportMsg(''), 3000);
  };

  const typeColor = (t) => {
    const map = { fire: GBC.fire, water: GBC.water, grass: GBC.grass, dark: GBC.dark, light: GBC.light, darklight: '#c4b5fd' };
    return map[t] || '#a0aec0';
  };

  const allCreatures = { ...STARTERS, ...WILD_CREATURES };

  const TABS = ['COMBAT', 'STATUS', 'SCARS', 'DIFFICULTY', 'BOSSES', 'SOULS', 'ENCOUNTERS', 'CREATURES', 'TYPE CHART', 'SIMULATOR'];

  // Styles
  const S = {
    overlay: {
      position: 'fixed', top: 0, right: 0, bottom: 0, width: 420, maxWidth: '100vw',
      background: 'rgba(10,10,10,0.97)', borderLeft: '1px solid #333',
      zIndex: 2050, display: 'flex', flexDirection: 'column',
      fontFamily: "'IBM Plex Mono', monospace", color: '#f0e6d3', fontSize: 12,
      animation: 'devSlideIn 0.2s ease-out'
    },
    header: {
      display: 'flex', alignItems: 'center', justifyContent: 'space-between',
      padding: '10px 14px', borderBottom: '1px solid #333', flexShrink: 0
    },
    tabBar: {
      display: 'flex', flexWrap: 'wrap', gap: 0, padding: '6px 10px',
      borderBottom: '1px solid #222', flexShrink: 0
    },
    tab: (active) => ({
      padding: '4px 8px', fontSize: 9, cursor: 'pointer', letterSpacing: 0.5,
      color: active ? '#f6e05e' : '#666', borderBottom: active ? '2px solid #f6e05e' : '2px solid transparent',
      background: 'none', border: 'none', fontFamily: "'IBM Plex Mono', monospace",
      transition: 'color 0.15s'
    }),
    content: {
      flex: 1, overflowY: 'auto', padding: '12px 14px',
      scrollbarWidth: 'thin', scrollbarColor: '#333 #0f0f0f'
    },
    section: { marginBottom: 16 },
    sectionTitle: { color: '#f6e05e', fontSize: 11, fontWeight: 'bold', marginBottom: 8, letterSpacing: 1 },
    btn: (c) => ({
      padding: '4px 10px', fontSize: 10, cursor: 'pointer', border: '1px solid ' + (c || '#555'),
      background: '#1a1a1a', color: c || '#a0aec0', borderRadius: 3,
      fontFamily: "'IBM Plex Mono', monospace"
    }),
    closeBtn: {
      background: 'none', border: 'none', color: '#666', fontSize: 18, cursor: 'pointer',
      fontFamily: "'IBM Plex Mono', monospace", padding: '0 4px', lineHeight: 1
    },
    dot: {
      width: 8, height: 8, borderRadius: '50%', background: '#fc8181',
      display: 'inline-block', marginRight: 8,
      animation: 'devPulse 1.5s ease-in-out infinite'
    },
    collapsible: (open) => ({
      cursor: 'pointer', padding: '6px 8px', background: '#1a1a1a', borderRadius: 3,
      marginBottom: open ? 0 : 6, display: 'flex', justifyContent: 'space-between', alignItems: 'center',
      border: '1px solid #282828'
    }),
    collapsibleBody: {
      padding: '8px', background: '#141414', borderRadius: '0 0 3px 3px',
      marginBottom: 6, border: '1px solid #282828', borderTop: 'none'
    }
  };

  // Inject keyframes once
  useEffect(() => {
    if (!document.getElementById('dev-dash-keyframes')) {
      const style = document.createElement('style');
      style.id = 'dev-dash-keyframes';
      style.textContent = `
        @keyframes devSlideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
        @keyframes devPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
        .dev-dash-scroll::-webkit-scrollbar { width: 6px; }
        .dev-dash-scroll::-webkit-scrollbar-track { background: #0f0f0f; }
        .dev-dash-scroll::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        .dev-dash input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: #f6e05e; cursor: pointer; border: none; }
        .dev-dash input[type="range"]::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: #f6e05e; cursor: pointer; border: none; }
      `;
      document.head.appendChild(style);
    }
  }, []);

  // ---- Tab renderers ----

  const renderCombat = () => (
    <div>
      <div style={S.sectionTitle}>DAMAGE</div>
      <ConfigSlider label="Guard Damage Reduction" value={getConfig('combat.guardDamageReduction')} min={0} max={1} step={0.05} onChange={v => updateConfig('combat.guardDamageReduction', v)} />
      <ConfigSlider label="Winded Damage Bonus" value={getConfig('combat.windedDamageBonus')} min={1} max={2} step={0.05} onChange={v => updateConfig('combat.windedDamageBonus', v)} color={GBC.red} />
      <ConfigSlider label="Scarred Damage Penalty" value={getConfig('combat.scarredDamagePenalty')} min={0.25} max={1} step={0.05} onChange={v => updateConfig('combat.scarredDamagePenalty', v)} color={GBC.dark} />
      <ConfigSlider label="Minimum Damage" value={getConfig('combat.minimumDamage')} min={0} max={10} step={1} onChange={v => updateConfig('combat.minimumDamage', v)} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>STAMINA</div>
      <ConfigSlider label="Winded Threshold" value={getConfig('combat.windedThreshold')} min={1} max={15} step={1} onChange={v => updateConfig('combat.windedThreshold', v)} color={GBC.red} />
      <ConfigSlider label="Winded Warning Threshold" value={getConfig('combat.windedWarningThreshold')} min={1} max={20} step={1} onChange={v => updateConfig('combat.windedWarningThreshold', v)} color="#f6ad55" />
      <ConfigSlider label="Stamina Per Turn Recovery" value={getConfig('combat.staminaPerTurnRecovery')} min={0} max={10} step={1} onChange={v => updateConfig('combat.staminaPerTurnRecovery', v)} color={GBC.green} />
      <ConfigSlider label="Rest Recovery Base" value={getConfig('combat.restRecoveryBase')} min={1} max={20} step={1} onChange={v => updateConfig('combat.restRecoveryBase', v)} color={GBC.green} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>THRESHOLDS</div>
      <ConfigSlider label="Scarred Damage Threshold (scars)" value={getConfig('combat.scarredDamageThreshold')} min={1} max={10} step={1} onChange={v => updateConfig('combat.scarredDamageThreshold', v)} />
    </div>
  );

  const renderStatus = () => (
    <div>
      <div style={S.sectionTitle}>BURN</div>
      <ConfigSlider label="Burn Duration (turns)" value={getConfig('statusFx.burnDuration')} min={1} max={8} step={1} onChange={v => updateConfig('statusFx.burnDuration', v)} color={GBC.fire} />
      <ConfigSlider label="Burn Damage" value={getConfig('statusFx.burnDamage')} min={1} max={15} step={1} onChange={v => updateConfig('statusFx.burnDamage', v)} color={GBC.fire} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>POISON</div>
      <ConfigSlider label="Poison Duration (turns)" value={getConfig('statusFx.poisonDuration')} min={1} max={8} step={1} onChange={v => updateConfig('statusFx.poisonDuration', v)} color={GBC.grass} />
      <ConfigSlider label="Poison Damage" value={getConfig('statusFx.poisonDamage')} min={1} max={15} step={1} onChange={v => updateConfig('statusFx.poisonDamage', v)} color={GBC.grass} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>CHILL</div>
      <ConfigSlider label="Chill Duration (turns)" value={getConfig('statusFx.chillDuration')} min={1} max={8} step={1} onChange={v => updateConfig('statusFx.chillDuration', v)} color={GBC.water} />
      <ConfigSlider label="Chill Skip Chance" value={getConfig('statusFx.chillSkipChance')} min={0} max={1} step={0.05} onChange={v => updateConfig('statusFx.chillSkipChance', v)} color={GBC.water} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>ARENA EFFECTS</div>
      <ConfigSlider label="Scorched Earth Damage" value={getConfig('statusFx.scorchedEarthDamage')} min={0} max={10} step={1} onChange={v => updateConfig('statusFx.scorchedEarthDamage', v)} color={GBC.fire} />
      <ConfigSlider label="Fractured Aura Damage" value={getConfig('statusFx.fracturedAuraDamage')} min={0} max={10} step={1} onChange={v => updateConfig('statusFx.fracturedAuraDamage', v)} color={GBC.dark} />
    </div>
  );

  const renderScars = () => (
    <div>
      <div style={S.sectionTitle}>HOLLOWED</div>
      <ConfigSlider label="Hollowed Stat Multiplier" value={getConfig('scars.hollowedStatMultiplier')} min={0.25} max={1} step={0.05} onChange={v => updateConfig('scars.hollowedStatMultiplier', v)} color={GBC.dark} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>SCAR TYPES</div>
      {SCAR_TYPES.map((scar, i) => (
        <div key={scar.id} style={{ marginBottom: 12, padding: 8, background: '#1a1a1a', borderRadius: 3, border: '1px solid #282828' }}>
          <div style={{ color: '#f6e05e', fontSize: 11, marginBottom: 6 }}>{scar.name} <span style={{ color: '#666', fontSize: 9 }}>({scar.id})</span></div>
          <div style={{ color: '#888', fontSize: 10, marginBottom: 4 }}>{scar.description}</div>
          {scar.value !== undefined && (
            <ConfigSlider
              label={`Effect value (${scar.effect})`}
              value={scar.value}
              min={-20}
              max={0}
              step={1}
              onChange={v => { SCAR_TYPES[i].value = v; SCAR_TYPES[i].description = `${v} ${scar.effect === 'maxHp' ? 'max HP' : 'max Stamina'}`; onModified(true); rerender(); }}
              color={GBC.red}
            />
          )}
        </div>
      ))}
    </div>
  );

  const renderDifficulty = () => {
    const diffKeys = Object.keys(DIFFICULTIES);
    const numericFields = ['wildDamageMult', 'bossDamageMult', 'soulDropPercent', 'captureBonus', 'bossHpMult', 'hollowedThreshold'];
    const boolFields = ['scarsHealAtBonfire', 'dropBankedSouls', 'bonfireHeals', 'permadeath', 'bossPhaseTransition'];
    const scarFields = ['hp', 'stamina'];

    return (
      <div>
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 8 }}>
          {diffKeys.map(dk => {
            const d = DIFFICULTIES[dk];
            return (
              <div key={dk} style={{ padding: 8, background: '#1a1a1a', borderRadius: 3, border: '1px solid #282828' }}>
                <div style={{ color: '#f6e05e', fontSize: 11, fontWeight: 'bold', marginBottom: 8, textAlign: 'center' }}>
                  {d.icon} {d.name}
                </div>
                {numericFields.map(f => {
                  const ranges = {
                    wildDamageMult: [0.25, 2, 0.05], bossDamageMult: [0.25, 2, 0.05],
                    soulDropPercent: [0, 2, 0.1], captureBonus: [-50, 50, 5],
                    bossHpMult: [0.5, 3, 0.05], hollowedThreshold: [1, 10, 1]
                  };
                  const [mn, mx, st] = ranges[f] || [0, 10, 1];
                  return (
                    <ConfigSlider key={f} label={f} value={d[f]} min={mn} max={mx} step={st}
                      onChange={v => { DIFFICULTIES[dk][f] = v; onModified(true); rerender(); }}
                    />
                  );
                })}
                {boolFields.map(f => (
                  <div key={f} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 4, fontSize: 10 }}>
                    <span style={{ color: '#a0aec0' }}>{f}</span>
                    <span
                      style={{ cursor: 'pointer', color: d[f] ? GBC.green : GBC.red, fontWeight: 'bold' }}
                      onClick={() => { DIFFICULTIES[dk][f] = !d[f]; onModified(true); rerender(); }}
                    >
                      {d[f] ? 'ON' : 'OFF'}
                    </span>
                  </div>
                ))}
                <div style={{ marginTop: 6, fontSize: 10, color: '#666' }}>Scar Penalties:</div>
                {scarFields.map(sf => (
                  <ConfigSlider key={sf} label={`scar ${sf}`} value={d.scarPenalties[sf]} min={-15} max={0} step={1}
                    onChange={v => { DIFFICULTIES[dk].scarPenalties[sf] = v; onModified(true); rerender(); }}
                    color={GBC.red}
                  />
                ))}
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  const renderBosses = () => (
    <div>
      <div style={S.sectionTitle}>GLOBAL</div>
      <ConfigSlider label="Phase Transition Threshold" value={getConfig('bosses.phaseTransitionThreshold')} min={0.1} max={0.7} step={0.05}
        onChange={v => updateConfig('bosses.phaseTransitionThreshold', v)} color={GBC.red} />
      <ConfigSlider label="Obsidian Hound Phase Heal" value={getConfig('bosses.obsidianHoundPhaseHeal')} min={0} max={50} step={1}
        onChange={v => updateConfig('bosses.obsidianHoundPhaseHeal', v)} color={GBC.fire} />
      <ConfigSlider label="Hollow Warden Phase Heal" value={getConfig('bosses.hollowWardenPhaseHeal')} min={0} max={50} step={1}
        onChange={v => updateConfig('bosses.hollowWardenPhaseHeal', v)} color={GBC.dark} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>BOSS DATA</div>
      {Object.entries(BOSS).map(([key, boss]) => (
        <div key={key}>
          <div style={S.collapsible(expandedBoss === key)} onClick={() => setExpandedBoss(expandedBoss === key ? null : key)}>
            <span style={{ color: typeColor(boss.type), fontWeight: 'bold', fontSize: 11 }}>{boss.name}</span>
            <span style={{ color: '#555', fontSize: 10 }}>{expandedBoss === key ? '[-]' : '[+]'}</span>
          </div>
          {expandedBoss === key && (
            <div style={S.collapsibleBody}>
              <ConfigSlider label="Max HP" value={boss.maxHp} min={20} max={200} step={5}
                onChange={v => { BOSS[key].maxHp = v; onModified(true); rerender(); }} color={GBC.red} />
              <ConfigSlider label="Max Stamina" value={boss.maxStamina} min={10} max={60} step={1}
                onChange={v => { BOSS[key].maxStamina = v; onModified(true); rerender(); }} color={GBC.blue} />
              <ConfigSlider label="Souls" value={boss.souls} min={10} max={500} step={10}
                onChange={v => { BOSS[key].souls = v; onModified(true); rerender(); }} color={GBC.gold} />
              <div style={{ color: '#888', fontSize: 10, marginTop: 8, marginBottom: 4 }}>Phase 1 Moves</div>
              {boss.moves.map((m, mi) => (
                <div key={mi} style={{ marginLeft: 8, marginBottom: 6 }}>
                  <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 2 }}>{m.name}</div>
                  {m.damage > 0 && <ConfigSlider label="Damage" value={m.damage} min={0} max={40} step={1}
                    onChange={v => { BOSS[key].moves[mi].damage = v; onModified(true); rerender(); }} color={GBC.red} />}
                  <ConfigSlider label="Cost" value={m.cost} min={0} max={20} step={1}
                    onChange={v => { BOSS[key].moves[mi].cost = v; onModified(true); rerender(); }} />
                </div>
              ))}
              {boss.phase2Moves && (
                <React.Fragment>
                  <div style={{ color: '#888', fontSize: 10, marginTop: 8, marginBottom: 4 }}>Phase 2 Moves</div>
                  {boss.phase2Moves.map((m, mi) => (
                    <div key={mi} style={{ marginLeft: 8, marginBottom: 6 }}>
                      <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 2 }}>{m.name}</div>
                      {m.damage > 0 && <ConfigSlider label="Damage" value={m.damage} min={0} max={40} step={1}
                        onChange={v => { BOSS[key].phase2Moves[mi].damage = v; onModified(true); rerender(); }} color={GBC.red} />}
                      <ConfigSlider label="Cost" value={m.cost} min={0} max={20} step={1}
                        onChange={v => { BOSS[key].phase2Moves[mi].cost = v; onModified(true); rerender(); }} />
                    </div>
                  ))}
                </React.Fragment>
              )}
            </div>
          )}
        </div>
      ))}
    </div>
  );

  const renderSouls = () => (
    <div>
      <div style={S.sectionTitle}>SOUL BIND</div>
      <ConfigSlider label="Bind Cost" value={getConfig('souls.bindCost')} min={5} max={100} step={5}
        onChange={v => updateConfig('souls.bindCost', v)} color={GBC.gold} />
      <ConfigSlider label="Max Team Size" value={getConfig('souls.maxTeamSize')} min={1} max={10} step={1}
        onChange={v => updateConfig('souls.maxTeamSize', v)} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>CAPTURE BRACKETS (% chance)</div>
      <ConfigSlider label="Under 10% HP" value={getConfig('souls.captureBrackets.under10')} min={0} max={100} step={5}
        onChange={v => updateConfig('souls.captureBrackets.under10', v)} color={GBC.green} />
      <ConfigSlider label="Under 25% HP" value={getConfig('souls.captureBrackets.under25')} min={0} max={100} step={5}
        onChange={v => updateConfig('souls.captureBrackets.under25', v)} color={GBC.green} />
      <ConfigSlider label="Under 50% HP" value={getConfig('souls.captureBrackets.under50')} min={0} max={100} step={5}
        onChange={v => updateConfig('souls.captureBrackets.under50', v)} color="#f6ad55" />
      <ConfigSlider label="Over 50% HP" value={getConfig('souls.captureBrackets.over50')} min={0} max={100} step={5}
        onChange={v => updateConfig('souls.captureBrackets.over50', v)} color={GBC.red} />
      <div style={{ ...S.sectionTitle, marginTop: 16 }}>CAPTURE CAPS</div>
      <ConfigSlider label="Capture Cap Min (%)" value={getConfig('souls.captureCapMin')} min={0} max={50} step={1}
        onChange={v => updateConfig('souls.captureCapMin', v)} />
      <ConfigSlider label="Capture Cap Max (%)" value={getConfig('souls.captureCapMax')} min={50} max={100} step={1}
        onChange={v => updateConfig('souls.captureCapMax', v)} />
    </div>
  );

  const renderEncounters = () => {
    const cfg = window.GAME_CONFIG.wildEncounters;
    return (
      <div>
        <div style={S.sectionTitle}>GLOBAL</div>
        <ConfigSlider label="Grass Encounter Chance" value={cfg.grassEncounterChance} min={0} max={1} step={0.05}
          onChange={v => updateConfig('wildEncounters.grassEncounterChance', v)} color={GBC.grass} />
        <ConfigSlider label="HP Variance Range" value={cfg.hpVarianceRange} min={1} max={30} step={1}
          onChange={v => updateConfig('wildEncounters.hpVarianceRange', v)} />
        <ConfigSlider label="Stamina Variance Range" value={cfg.staminaVarianceRange} min={1} max={15} step={1}
          onChange={v => updateConfig('wildEncounters.staminaVarianceRange', v)} />

        <div style={{ ...S.sectionTitle, marginTop: 16 }}>SURFACE</div>
        <ConfigSlider label="HP Floor" value={cfg.surface.hpFloor} min={5} max={50} step={1}
          onChange={v => updateConfig('wildEncounters.surface.hpFloor', v)} />
        <ConfigSlider label="Stamina Floor" value={cfg.surface.staminaFloor} min={5} max={30} step={1}
          onChange={v => updateConfig('wildEncounters.surface.staminaFloor', v)} />
        <ConfigSlider label="Pre-scar Chance" value={cfg.surface.preScarChance} min={0} max={1} step={0.05}
          onChange={v => updateConfig('wildEncounters.surface.preScarChance', v)} color={GBC.red} />

        <div style={{ ...S.sectionTitle, marginTop: 16 }}>DEEP</div>
        <ConfigSlider label="HP Floor" value={cfg.deep.hpFloor} min={5} max={60} step={1}
          onChange={v => updateConfig('wildEncounters.deep.hpFloor', v)} />
        <ConfigSlider label="Stamina Floor" value={cfg.deep.staminaFloor} min={5} max={30} step={1}
          onChange={v => updateConfig('wildEncounters.deep.staminaFloor', v)} />
        <ConfigSlider label="Pre-scar Chance" value={cfg.deep.preScarChance} min={0} max={1} step={0.05}
          onChange={v => updateConfig('wildEncounters.deep.preScarChance', v)} color={GBC.red} />
        <ConfigSlider label="HP Bonus" value={cfg.deep.hpBonus} min={0} max={20} step={1}
          onChange={v => updateConfig('wildEncounters.deep.hpBonus', v)} />
        <ConfigSlider label="Stamina Bonus" value={cfg.deep.staminaBonus} min={0} max={10} step={1}
          onChange={v => updateConfig('wildEncounters.deep.staminaBonus', v)} />
        <ConfigSlider label="Umbravine Chance" value={cfg.deep.umbravineChance} min={0} max={1} step={0.05}
          onChange={v => updateConfig('wildEncounters.deep.umbravineChance', v)} color={GBC.dark} />
        <ConfigSlider label="Umbravine Souls" value={cfg.deep.umbravineSouls} min={5} max={60} step={1}
          onChange={v => updateConfig('wildEncounters.deep.umbravineSouls', v)} color={GBC.gold} />
        <ConfigSlider label="Solrath Souls" value={cfg.deep.solrathSouls} min={5} max={60} step={1}
          onChange={v => updateConfig('wildEncounters.deep.solrathSouls', v)} color={GBC.gold} />

        <div style={{ ...S.sectionTitle, marginTop: 16 }}>LABYRINTH</div>
        <ConfigSlider label="HP Floor" value={cfg.labyrinth.hpFloor} min={5} max={80} step={1}
          onChange={v => updateConfig('wildEncounters.labyrinth.hpFloor', v)} />
        <ConfigSlider label="Stamina Floor" value={cfg.labyrinth.staminaFloor} min={5} max={30} step={1}
          onChange={v => updateConfig('wildEncounters.labyrinth.staminaFloor', v)} />
        <ConfigSlider label="Pre-scar Chance" value={cfg.labyrinth.preScarChance} min={0} max={1} step={0.05}
          onChange={v => updateConfig('wildEncounters.labyrinth.preScarChance', v)} color={GBC.red} />
        <ConfigSlider label="HP Bonus" value={cfg.labyrinth.hpBonus} min={0} max={30} step={1}
          onChange={v => updateConfig('wildEncounters.labyrinth.hpBonus', v)} />
        <ConfigSlider label="Stamina Bonus" value={cfg.labyrinth.staminaBonus} min={0} max={15} step={1}
          onChange={v => updateConfig('wildEncounters.labyrinth.staminaBonus', v)} />
        <ConfigSlider label="Souls" value={cfg.labyrinth.souls} min={5} max={60} step={1}
          onChange={v => updateConfig('wildEncounters.labyrinth.souls', v)} color={GBC.gold} />
      </div>
    );
  };

  const renderCreatures = () => {
    const groups = [
      { title: 'STARTERS', src: STARTERS, ref: 'STARTERS' },
      { title: 'WILD', src: WILD_CREATURES, ref: 'WILD_CREATURES' }
    ];
    return (
      <div>
        {groups.map(g => (
          <div key={g.title}>
            <div style={S.sectionTitle}>{g.title}</div>
            {Object.entries(g.src).map(([key, creature]) => (
              <div key={key}>
                <div style={S.collapsible(expandedCreature === key)} onClick={() => setExpandedCreature(expandedCreature === key ? null : key)}>
                  <span style={{ color: typeColor(creature.type), fontWeight: 'bold', fontSize: 11 }}>
                    {creature.name}
                  </span>
                  <span style={{ color: '#555', fontSize: 10 }}>{expandedCreature === key ? '[-]' : '[+]'}</span>
                </div>
                {expandedCreature === key && (
                  <div style={S.collapsibleBody}>
                    <ConfigSlider label="Max HP" value={creature.maxHp} min={10} max={100} step={1}
                      onChange={v => { g.src[key].maxHp = v; onModified(true); rerender(); }} color={GBC.red} />
                    <ConfigSlider label="Max Stamina" value={creature.maxStamina} min={5} max={50} step={1}
                      onChange={v => { g.src[key].maxStamina = v; onModified(true); rerender(); }} color={GBC.blue} />
                    {creature.souls !== undefined && (
                      <ConfigSlider label="Souls" value={creature.souls} min={1} max={100} step={1}
                        onChange={v => { g.src[key].souls = v; onModified(true); rerender(); }} color={GBC.gold} />
                    )}
                    <div style={{ color: '#888', fontSize: 10, marginTop: 8, marginBottom: 4 }}>Moves</div>
                    {creature.moves.map((m, mi) => (
                      <div key={mi} style={{ marginLeft: 8, marginBottom: 6 }}>
                        <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 2 }}>{m.name}</div>
                        {m.damage > 0 && <ConfigSlider label="Damage" value={m.damage} min={0} max={30} step={1}
                          onChange={v => { g.src[key].moves[mi].damage = v; onModified(true); rerender(); }} color={GBC.red} />}
                        <ConfigSlider label="Cost" value={m.cost} min={0} max={15} step={1}
                          onChange={v => { g.src[key].moves[mi].cost = v; onModified(true); rerender(); }} />
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </div>
        ))}
      </div>
    );
  };

  const renderTypeChart = () => {
    const types = Object.keys(TYPE_CHART);
    const cellColor = (v) => {
      if (v >= 2.0) return '#fc8181';
      if (v >= 1.5) return '#f6ad55';
      if (v > 1.0) return '#faf089';
      if (v === 1.0) return '#555';
      if (v >= 0.75) return '#a0aec0';
      return '#68d391';
    };
    const cycleValue = (v) => {
      if (v <= 0.5) return 0.75;
      if (v <= 0.75) return 1.0;
      if (v <= 1.0) return 1.25;
      if (v <= 1.25) return 1.5;
      if (v <= 1.5) return 2.0;
      return 0.5;
    };

    return (
      <div>
        <div style={S.sectionTitle}>CLICK TO CYCLE: 0.5  0.75  1.0  1.25  1.5  2.0</div>
        <div style={{ overflowX: 'auto' }}>
          <table style={{ borderCollapse: 'collapse', fontSize: 10, width: '100%' }}>
            <thead>
              <tr>
                <th style={{ padding: 4, color: '#666', textAlign: 'left' }}>ATK \ DEF</th>
                {types.map(t => (
                  <th key={t} style={{ padding: 4, color: typeColor(t), textAlign: 'center', fontSize: 9 }}>
                    {t.slice(0, 4).toUpperCase()}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {types.map(atkType => (
                <tr key={atkType}>
                  <td style={{ padding: 4, color: typeColor(atkType), fontWeight: 'bold', fontSize: 9 }}>
                    {atkType.slice(0, 4).toUpperCase()}
                  </td>
                  {types.map(defType => {
                    const v = TYPE_CHART[atkType][defType];
                    return (
                      <td key={defType}
                        onClick={() => { TYPE_CHART[atkType][defType] = cycleValue(v); onModified(true); rerender(); }}
                        style={{
                          padding: 4, textAlign: 'center', cursor: 'pointer',
                          background: cellColor(v) + '22', color: cellColor(v),
                          fontWeight: v !== 1.0 ? 'bold' : 'normal',
                          border: '1px solid #222', minWidth: 36
                        }}
                      >
                        {v.toFixed(1)}x
                      </td>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    );
  };

  const renderSimulator = () => {
    const creatureList = Object.entries(allCreatures);
    const atkCreature = allCreatures[simAttacker];
    const defCreature = allCreatures[simDefender];
    const atkMoves = atkCreature ? atkCreature.moves : [];
    const move = atkMoves[simMove] || atkMoves[0];
    const diff = DIFFICULTIES[simDifficulty] || DIFFICULTIES.scarred;

    let result = null;
    if (atkCreature && defCreature && move) {
      const fakeAttacker = {
        ...atkCreature, hp: atkCreature.maxHp, stamina: atkCreature.maxStamina,
        scars: simScarred ? [{ id: 'fractured' }, { id: 'hesitant' }, { id: 'flinching' }] : []
      };
      const fakeDefender = {
        ...defCreature, hp: defCreature.maxHp, stamina: defCreature.maxStamina,
        isGuarding: simGuarding, winded: simWinded, scars: []
      };
      const diffMult = 1.0; // Player attacking, no difficulty mult
      const rawDmg = move.damage;
      const effectiveness = TYPE_CHART[atkCreature.type]?.[defCreature.type] ?? 1.0;
      let damage = Math.floor(rawDmg * effectiveness);
      if (simGuarding) damage = Math.floor(damage * window.GAME_CONFIG.combat.guardDamageReduction);
      if (simWinded) damage = Math.floor(damage * window.GAME_CONFIG.combat.windedDamageBonus);
      if (simScarred && fakeAttacker.scars.length >= window.GAME_CONFIG.combat.scarredDamageThreshold) {
        damage = Math.floor(damage * window.GAME_CONFIG.combat.scarredDamagePenalty);
      }
      damage = Math.max(window.GAME_CONFIG.combat.minimumDamage, damage);

      result = { rawDmg, effectiveness, damage, move };
    }

    return (
      <div>
        <div style={S.sectionTitle}>DAMAGE SIMULATOR</div>
        <div style={{ marginBottom: 8 }}>
          <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 4 }}>Attacker</div>
          <select value={simAttacker} onChange={e => { setSimAttacker(e.target.value); setSimMove(0); }}
            style={{ width: '100%', padding: 6, background: '#1a1a1a', color: '#f0e6d3', border: '1px solid #333', borderRadius: 3, fontFamily: "'IBM Plex Mono', monospace", fontSize: 11 }}>
            {creatureList.map(([k, c]) => <option key={k} value={k}>{c.name} ({c.type})</option>)}
          </select>
        </div>
        <div style={{ marginBottom: 8 }}>
          <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 4 }}>Move</div>
          <select value={simMove} onChange={e => setSimMove(parseInt(e.target.value))}
            style={{ width: '100%', padding: 6, background: '#1a1a1a', color: '#f0e6d3', border: '1px solid #333', borderRadius: 3, fontFamily: "'IBM Plex Mono', monospace", fontSize: 11 }}>
            {atkMoves.map((m, i) => <option key={i} value={i}>{m.name} (dmg:{m.damage} cost:{m.cost})</option>)}
          </select>
        </div>
        <div style={{ marginBottom: 8 }}>
          <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 4 }}>Defender</div>
          <select value={simDefender} onChange={e => setSimDefender(e.target.value)}
            style={{ width: '100%', padding: 6, background: '#1a1a1a', color: '#f0e6d3', border: '1px solid #333', borderRadius: 3, fontFamily: "'IBM Plex Mono', monospace", fontSize: 11 }}>
            {creatureList.map(([k, c]) => <option key={k} value={k}>{c.name} ({c.type})</option>)}
          </select>
        </div>
        <div style={{ marginBottom: 8 }}>
          <div style={{ color: '#a0aec0', fontSize: 10, marginBottom: 4 }}>Difficulty</div>
          <select value={simDifficulty} onChange={e => setSimDifficulty(e.target.value)}
            style={{ width: '100%', padding: 6, background: '#1a1a1a', color: '#f0e6d3', border: '1px solid #333', borderRadius: 3, fontFamily: "'IBM Plex Mono', monospace", fontSize: 11 }}>
            {Object.entries(DIFFICULTIES).map(([k, d]) => <option key={k} value={k}>{d.name}</option>)}
          </select>
        </div>
        <div style={{ display: 'flex', gap: 16, marginBottom: 12, fontSize: 11 }}>
          <label style={{ display: 'flex', alignItems: 'center', gap: 4, cursor: 'pointer', color: '#a0aec0' }}>
            <input type="checkbox" checked={simWinded} onChange={e => setSimWinded(e.target.checked)} /> Winded
          </label>
          <label style={{ display: 'flex', alignItems: 'center', gap: 4, cursor: 'pointer', color: '#a0aec0' }}>
            <input type="checkbox" checked={simGuarding} onChange={e => setSimGuarding(e.target.checked)} /> Guarding
          </label>
          <label style={{ display: 'flex', alignItems: 'center', gap: 4, cursor: 'pointer', color: '#a0aec0' }}>
            <input type="checkbox" checked={simScarred} onChange={e => setSimScarred(e.target.checked)} /> Scarred (3)
          </label>
        </div>

        {result && (
          <div style={{ background: '#1a1a1a', border: '1px solid #333', borderRadius: 4, padding: 12 }}>
            <div style={{ fontSize: 10, color: '#888', marginBottom: 8 }}>RESULT</div>
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 6, fontSize: 11 }}>
              <div style={{ color: '#a0aec0' }}>Base Damage:</div>
              <div style={{ color: '#f0e6d3', textAlign: 'right' }}>{result.rawDmg}</div>
              <div style={{ color: '#a0aec0' }}>Type Effectiveness:</div>
              <div style={{ color: result.effectiveness > 1 ? GBC.red : result.effectiveness < 1 ? GBC.green : '#f0e6d3', textAlign: 'right' }}>
                {result.effectiveness.toFixed(2)}x {result.effectiveness > 1 ? '(super effective)' : result.effectiveness < 1 ? '(not effective)' : '(neutral)'}
              </div>
              {simGuarding && (
                <React.Fragment>
                  <div style={{ color: '#a0aec0' }}>Guard Reduction:</div>
                  <div style={{ color: GBC.blue, textAlign: 'right' }}>x{window.GAME_CONFIG.combat.guardDamageReduction}</div>
                </React.Fragment>
              )}
              {simWinded && (
                <React.Fragment>
                  <div style={{ color: '#a0aec0' }}>Winded Bonus:</div>
                  <div style={{ color: GBC.red, textAlign: 'right' }}>x{window.GAME_CONFIG.combat.windedDamageBonus}</div>
                </React.Fragment>
              )}
              {simScarred && (
                <React.Fragment>
                  <div style={{ color: '#a0aec0' }}>Scarred Penalty:</div>
                  <div style={{ color: GBC.dark, textAlign: 'right' }}>x{window.GAME_CONFIG.combat.scarredDamagePenalty}</div>
                </React.Fragment>
              )}
            </div>
            <div style={{ borderTop: '1px solid #333', marginTop: 8, paddingTop: 8, display: 'flex', justifyContent: 'space-between' }}>
              <span style={{ color: '#f6e05e', fontWeight: 'bold', fontSize: 16 }}>FINAL: {result.damage}</span>
              {defCreature && (
                <span style={{ color: '#888', fontSize: 11, alignSelf: 'center' }}>
                  ({Math.ceil(defCreature.maxHp / Math.max(1, result.damage))} hits to KO)
                </span>
              )}
            </div>
          </div>
        )}
      </div>
    );
  };

  const renderActiveTab = () => {
    switch (activeTab) {
      case 'COMBAT': return renderCombat();
      case 'STATUS': return renderStatus();
      case 'SCARS': return renderScars();
      case 'DIFFICULTY': return renderDifficulty();
      case 'BOSSES': return renderBosses();
      case 'SOULS': return renderSouls();
      case 'ENCOUNTERS': return renderEncounters();
      case 'CREATURES': return renderCreatures();
      case 'TYPE CHART': return renderTypeChart();
      case 'SIMULATOR': return renderSimulator();
      default: return null;
    }
  };

  return (
    <div className="dev-dash" style={S.overlay}>
      {/* Header */}
      <div style={S.header}>
        <div style={{ display: 'flex', alignItems: 'center' }}>
          <span style={S.dot} />
          <span style={{ color: '#f6e05e', fontWeight: 'bold', fontSize: 13, letterSpacing: 1 }}>LIVE BALANCE</span>
        </div>
        <div style={{ display: 'flex', gap: 6, alignItems: 'center' }}>
          <button style={S.btn('#fc8181')} onClick={resetAll} title="Reset all to defaults">RESET ALL</button>
          <button style={S.btn('#68d391')} onClick={doExport} title="Copy config JSON to clipboard">EXPORT</button>
          <button style={S.btn('#63b3ed')} onClick={() => setActiveTab(activeTab === 'IMPORT' ? 'COMBAT' : 'IMPORT')} title="Import config JSON">IMPORT</button>
          <button style={S.closeBtn} onClick={onClose} title="Close dashboard">&times;</button>
        </div>
      </div>

      {/* Tab bar */}
      <div style={S.tabBar}>
        {TABS.map(t => (
          <button key={t} style={S.tab(activeTab === t)} onClick={() => setActiveTab(t)}>{t}</button>
        ))}
      </div>

      {/* Content */}
      <div className="dev-dash-scroll" style={S.content}>
        {activeTab === 'IMPORT' ? (
          <div>
            <div style={S.sectionTitle}>IMPORT CONFIG</div>
            <textarea
              value={importText}
              onChange={e => setImportText(e.target.value)}
              placeholder="Paste exported JSON here..."
              style={{
                width: '100%', height: 200, background: '#1a1a1a', color: '#f0e6d3',
                border: '1px solid #333', borderRadius: 3, padding: 8, resize: 'vertical',
                fontFamily: "'IBM Plex Mono', monospace", fontSize: 10
              }}
            />
            <div style={{ marginTop: 8, display: 'flex', gap: 8, alignItems: 'center' }}>
              <button style={S.btn('#68d391')} onClick={doImport}>APPLY</button>
              {importMsg && <span style={{ color: importMsg.includes('fail') ? GBC.red : GBC.green, fontSize: 10 }}>{importMsg}</span>}
            </div>
          </div>
        ) : (
          <div>
            {/* Per-tab reset */}
            {activeTab !== 'SIMULATOR' && (
              <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: 10 }}>
                <button style={S.btn('#fc8181')} onClick={resetTab}>RESET {activeTab}</button>
              </div>
            )}
            {renderActiveTab()}
          </div>
        )}
      </div>
    </div>
  );
};


    // ============= MAIN APP =============
    function ScarsOfAsh() {
      const [state, dispatch] = useReducer(gameReducer, initialState);
      const [hasStarted, setHasStarted] = useState(false);
      const [muted, setMuted] = useState(true);
      const [audioStarted, setAudioStarted] = useState(false);
      const [showHelp, setShowHelp] = useState(false);
      const [showPauseMenu, setShowPauseMenu] = useState(false);
      const [showStats, setShowStats] = useState(false);
      const [showFallen, setShowFallen] = useState(false);
      const [confirmDialog, setConfirmDialog] = useState(null);
      const [checkingSave, setCheckingSave] = useState(true);
      const [existingSave, setExistingSave] = useState(null);
      const devEnabledRef = useRef(new URLSearchParams(window.location.search).get('dev') === 'true');
      const [showDevDashboard, setShowDevDashboard] = useState(false);
      const [devModified, setDevModified] = useState(false);
      const prevBonfireRef = useRef(null);
      const playTimeRef = useRef(Date.now());

      // Handle tap to start
      const handleStart = async () => {
        try {
          await musicManager.init();
          await sfxManager.init();
          setAudioStarted(true);
          setMuted(false);
          sfxManager.setMuted(false);
        } catch (e) {
          // Audio init failed, continue anyway
          console.warn('Audio initialization failed:', e);
        }
        setHasStarted(true);
      };

      // Check for existing save on mount
      useEffect(() => {
        const save = loadSaveData();
        if (save && save.team && save.team.length > 0) {
          setExistingSave(save);
        }
        setCheckingSave(false);
      }, []);

      // Show help on first visit (only if no save screen)
      useEffect(() => {
        if (!checkingSave && !existingSave) {
          const hasSeenHelp = localStorage.getItem('scarsOfAshHelpSeen');
          if (!hasSeenHelp) {
            setShowHelp(true);
          }
        }
      }, [checkingSave, existingSave]);

      // Track play time
      useEffect(() => {
        if (state.screen === 'exploration' || state.screen === 'battle') {
          const interval = setInterval(() => {
            const now = Date.now();
            const delta = now - playTimeRef.current;
            playTimeRef.current = now;
            dispatch({ type: 'UPDATE_PLAY_TIME', delta });
          }, 1000);
          return () => clearInterval(interval);
        }
        playTimeRef.current = Date.now();
      }, [state.screen]);

      // Handle ESC key for pause menu
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Escape') {
            // Don't open pause in certain screens
            if (state.screen === 'starter' || state.screen === 'victory' ||
                state.screen === 'credits' || state.screen === 'gameOver') {
              return;
            }
            // Close help first if open
            if (showHelp) {
              setShowHelp(false);
              return;
            }
            // Close confirm dialog if open
            if (confirmDialog) {
              setConfirmDialog(null);
              return;
            }
            // Toggle pause menu
            setShowPauseMenu(prev => !prev);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [state.screen, showHelp, confirmDialog]);

      // Handle backtick key for dev dashboard (only when enabled via URL param)
      useEffect(() => {
        if (!devEnabledRef.current) return;
        const handleBacktick = (e) => {
          if (e.key === '`') {
            e.preventDefault();
            setShowDevDashboard(prev => !prev);
          }
        };
        window.addEventListener('keydown', handleBacktick);
        return () => window.removeEventListener('keydown', handleBacktick);
      }, []);

      const handleCloseHelp = () => {
        setShowHelp(false);
        localStorage.setItem('scarsOfAshHelpSeen', 'true');
      };

      // Check if player is currently on a bonfire tile
      const isOnBonfire = useCallback(() => {
        const map = state.currentMap === 'ashenPath' ? ASHEN_PATH : state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : state.currentMap === 'labyrinth' ? LABYRINTH : FALLEN_KEEP;
        const tile = map[state.playerPos.y]?.[state.playerPos.x];
        return tile === 'B';
      }, [state.currentMap, state.playerPos]);

      // Compute the desired track based on game state
      const desiredTrack = (() => {
        if (state.screen === 'difficulty' || state.screen === 'starter') return null;
        if (state.screen === 'prologue') return 'bonfire';
        if (state.screen === 'victory') return 'victory';
        if (state.screen === 'credits') return 'bonfire';
        if (state.screen === 'gameOver') return 'gameOver';
        if (state.screen === 'battle') {
          if (state.isBossFight && state.bossPhase === 2) return 'bossPhase2';
          return 'battle';
        }
        if (state.screen === 'exploration') {
          return isOnBonfire() ? 'bonfire' : 'exploration';
        }
        return null;
      })();

      // Handle music transitions
      useEffect(() => {
        if (!audioStarted || muted) return;
        if (desiredTrack) {
          musicManager.switchTrack(desiredTrack);
        }
      }, [desiredTrack, audioStarted, muted]);

      const getTrackForState = useCallback(() => desiredTrack, [desiredTrack]);

      const handleToggleMute = async () => {
        if (!audioStarted) {
          await musicManager.init();
          await sfxManager.init();
          setAudioStarted(true);
          setMuted(false);
          sfxManager.setMuted(false);
          const track = getTrackForState();
          if (track) {
            musicManager.switchTrack(track);
          }
        } else {
          const newMuted = musicManager.toggleMute();
          setMuted(newMuted);
          sfxManager.setMuted(newMuted);
        }
      };

      // Track statistics
      const prevScreenRef = useRef(state.screen);
      const prevTeamLengthRef = useRef(state.team.length);
      const prevScarsRef = useRef(state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0));

      useEffect(() => {
        // Track run start when moving from starter to exploration
        if (prevScreenRef.current === 'starter' && state.screen === 'exploration') {
          recordRunStart();
        }
        // Track death when going to gameOver
        if (state.screen === 'gameOver' && prevScreenRef.current !== 'gameOver') {
          recordDeath();
        }
        // Track victory
        if (state.screen === 'victory' && prevScreenRef.current !== 'victory') {
          const totalScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
          recordVictory(state.difficulty, state.playTime, totalScars, state.currentMap === 'hollowDeep');
        }
        prevScreenRef.current = state.screen;
      }, [state.screen, state.difficulty, state.playTime, state.team, state.currentMap]);

      useEffect(() => {
        // Track capture when team grows
        if (state.team.length > prevTeamLengthRef.current) {
          const newCreature = state.team[state.team.length - 1];
          if (newCreature) {
            recordCapture(newCreature.id);
          }
        }
        prevTeamLengthRef.current = state.team.length;
      }, [state.team.length, state.team]);

      useEffect(() => {
        // Track scar when total increases
        const currentScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
        if (currentScars > prevScarsRef.current) {
          for (let i = 0; i < currentScars - prevScarsRef.current; i++) {
            recordScar();
          }
        }
        prevScarsRef.current = currentScars;
      }, [state.team]);

      // Pause menu handlers
      const handleResume = () => setShowPauseMenu(false);

      const handleSave = () => {
        dispatch({ type: 'MANUAL_SAVE' });
        setShowPauseMenu(false);
      };

      const handleLoadRequest = () => {
        const save = loadSaveData();
        if (save) {
          setConfirmDialog({
            message: 'Load saved game? Unsaved progress will be lost.',
            onConfirm: () => {
              dispatch({ type: 'LOAD_GAME', saveData: save });
              setConfirmDialog(null);
              setShowPauseMenu(false);
            },
            onCancel: () => setConfirmDialog(null)
          });
        }
      };

      const handleNewGameRequest = () => {
        setConfirmDialog({
          message: 'Abandon this run? All progress will be lost.',
          onConfirm: () => {
            dispatch({ type: 'NEW_GAME_CONFIRMED' });
            setConfirmDialog(null);
            setShowPauseMenu(false);
            setExistingSave(null);
          },
          onCancel: () => setConfirmDialog(null)
        });
      };

      const handleHelpFromPause = () => {
        setShowPauseMenu(false);
        setShowHelp(true);
      };

      // Load screen handlers
      const handleContinueSave = () => {
        if (existingSave) {
          dispatch({ type: 'LOAD_GAME', saveData: existingSave });
          setExistingSave(null);
        }
      };

      const handleNewGameFromLoad = () => {
        setConfirmDialog({
          message: 'Start new game? Saved progress will be lost.',
          onConfirm: () => {
            deleteSaveData();
            setExistingSave(null);
            setConfirmDialog(null);
          },
          onCancel: () => setConfirmDialog(null)
        });
      };

      // Show tap to start screen (must be after all hooks)
      if (!hasStarted) {
        return <TapToStart onStart={handleStart} />;
      }

      // Show loading state
      if (checkingSave) {
        return (
          <div style={styles.container}>
            <div style={{ textAlign: 'center', padding: '40px', color: GBC.textDim }}>
              ...
            </div>
          </div>
        );
      }

      // Show load screen if save exists and we're at character creation or difficulty screen
      if (existingSave && (state.screen === 'characterCreate' || state.screen === 'difficulty')) {
        return (
          <div style={styles.container}>
            <LoadScreen
              saveData={existingSave}
              onContinue={handleContinueSave}
              onNewGame={handleNewGameFromLoad}
            />
            {confirmDialog && (
              <ConfirmDialog
                message={confirmDialog.message}
                onConfirm={confirmDialog.onConfirm}
                onCancel={confirmDialog.onCancel}
              />
            )}
          </div>
        );
      }

      // Check if pause menu is allowed
      const canPause = state.screen === 'exploration' || state.screen === 'battle' || state.screen === 'prologue';
      const hasSave = !!loadSaveData();

      return (
        <div style={styles.container}>
          {canPause && <GearButton onClick={() => setShowPauseMenu(true)} />}
          <HelpButton onClick={() => setShowHelp(true)} />
          <MuteButton muted={muted} onToggle={handleToggleMute} />

          {showHelp && <HelpOverlay onClose={handleCloseHelp} />}

          {showPauseMenu && canPause && (
            <PauseMenu
              onResume={handleResume}
              onSave={handleSave}
              onLoad={handleLoadRequest}
              onNewGame={handleNewGameRequest}
              onHelp={handleHelpFromPause}
              hasSave={hasSave}
              state={state}
            />
          )}

          {confirmDialog && (
            <ConfirmDialog
              message={confirmDialog.message}
              onConfirm={confirmDialog.onConfirm}
              onCancel={confirmDialog.onCancel}
            />
          )}

          {state.saveNotification && (
            <SaveNotification
              message={state.saveNotification}
              onDismiss={() => dispatch({ type: 'CLEAR_NOTIFICATION' })}
            />
          )}

          {/* Difficulty indicator during gameplay */}
          {(state.screen === 'exploration' || state.screen === 'battle') && (
            <DifficultyIndicator difficulty={state.difficulty} />
          )}

          {state.screen === 'characterCreate' && (
            <CharacterCreate dispatch={dispatch} />
          )}
          {state.screen === 'difficulty' && !showStats && !showFallen && (
            <DifficultySelect dispatch={dispatch} onShowStats={() => setShowStats(true)} onShowFallen={() => setShowFallen(true)} />
          )}
          {state.screen === 'difficulty' && showStats && (
            <StatsScreen onClose={() => setShowStats(false)} />
          )}
          {state.screen === 'difficulty' && showFallen && (
            <HallOfFallen onClose={() => setShowFallen(false)} />
          )}
          {state.screen === 'starter' && (
            <StarterSelect dispatch={dispatch} />
          )}
          {state.screen === 'prologue' && (
            <Prologue dispatch={dispatch} state={state} />
          )}
          {state.screen === 'exploration' && (
            <Exploration state={state} dispatch={dispatch} />
          )}
          {state.screen === 'battle' && (
            <Battle state={state} dispatch={dispatch} />
          )}
          {state.screen === 'victory' && (
            <Victory state={state} dispatch={dispatch} />
          )}
          {state.screen === 'gameOver' && (
            <GameOver state={state} dispatch={dispatch} />
          )}
          {state.screen === 'nickname' && (
            <NicknameScreen creature={state.pendingCreature} dispatch={dispatch} />
          )}
          {state.screen === 'release' && (
            <ReleaseScreen state={state} dispatch={dispatch} />
          )}
          {state.screen === 'encounterPreview' && (
            <EncounterPreview encounter={state.pendingEncounter} dispatch={dispatch} />
          )}
          {state.screen === 'credits' && (
            <Credits dispatch={dispatch} />
          )}

          {/* DEV badge */}
          {devEnabledRef.current && devModified && (
            <div
              onClick={() => setShowDevDashboard(true)}
              style={{
                position: 'fixed', top: 8, left: 8,
                background: '#fc8181', color: '#1a0a0a',
                padding: '2px 8px', fontSize: 10,
                fontFamily: "'IBM Plex Mono', monospace",
                fontWeight: 'bold', letterSpacing: 1,
                borderRadius: 2, cursor: 'pointer', zIndex: 1001
              }}
            >
              DEV
            </div>
          )}

          {/* Dev Dashboard */}
          {devEnabledRef.current && showDevDashboard && (
            <DevDashboard
              onClose={() => setShowDevDashboard(false)}
              onModified={setDevModified}
            />
          )}
        </div>
      );
    }

    // Start preloading sprites in background (non-blocking)
    preloadSprites().catch(err => console.warn('Sprite preload failed:', err));

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ScarsOfAsh />);
  </script>
</body>
</html>
